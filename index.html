<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>The Seven Heavenly Virtues - 3D</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden;
            font-family: 'Courier New', monospace; 
            color: #eee;
            position: fixed;
            width: 100%;
            height: 100%;
            /* Support for dynamic viewport height on mobile */
            height: 100vh;
            height: -webkit-fill-available;
        }
        html {
            height: -webkit-fill-available;
        }
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
            height: -webkit-fill-available !important;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; /* Prevent default touch behaviors */
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            height: -webkit-fill-available;
            position: relative;
        }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: clamp(10px, 2vw, 15px);
            border-radius: 5px;
            border: 2px solid #f39c12;
            z-index: 100;
            font-size: clamp(11px, 2vw, 14px);
            line-height: 1.6;
            max-width: calc(100vw - 40px);
            box-sizing: border-box;
        }
        @media (max-width: 768px) {
            #hud {
                top: 10px;
                left: 10px;
                right: 10px;
                font-size: 11px;
            }
        }
        #hud strong { color: #f39c12; }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #f39c12;
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        #message {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #2ecc71;
            font-size: 16px;
            display: none;
            z-index: 100;
            text-align: center;
            max-width: 80%;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
            z-index: 100;
        }
        
        /* FF-Style Stat Bars - Ultra Minimal */
        .stat-bar-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .stat-label {
            font-size: clamp(8px, 1.2vw, 9px);
            color: #bdc3c7;
            min-width: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 1);
        }
        
        .stat-bar {
            flex: 1;
            height: clamp(8px, 1.5vh, 10px);
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        
        .stat-bar-fill {
            height: 100%;
            transition: width 0.4s ease;
            position: relative;
        }
        
        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
        }
        
        .hp-bar .stat-bar-fill {
            background: linear-gradient(90deg, #16a085 0%, #1abc9c 50%, #16a085 100%);
        }
        
        .mp-bar .stat-bar-fill {
            background: linear-gradient(90deg, #2471a3 0%, #3498db 50%, #2471a3 100%);
        }
        
        .stat-value {
            font-size: clamp(8px, 1.2vw, 9px);
            color: #ecf0f1;
            font-weight: bold;
            min-width: 50px;
            text-align: right;
            text-shadow: 2px 2px 3px rgba(0, 0, 0, 1);
        }
        
        .enemy-hp-bar {
            display: none;
        }
        
        .enemy-hp-fill {
            display: none;
        }
        
        /* Battle Log & Actions - Ultra Minimal */
        #battle-log {
            display: none;
        }
        
        #battle-actions {
            display: flex;
            flex-direction: column;
            gap: 1px;
            padding: clamp(4px, 1vw, 6px);
            background: rgba(0, 0, 0, 0.05);
        }
        
        .battle-btn {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.3) 0%, rgba(44, 62, 80, 0.3) 100%);
            color: #ecf0f1;
            border: 1px solid rgba(149, 165, 166, 0.2);
            border-left: 2px solid rgba(52, 152, 219, 0.3);
            padding: clamp(4px, 1vw, 6px) clamp(6px, 1.5vw, 10px);
            font-size: clamp(9px, 1.3vw, 11px);
            font-weight: bold;
            border-radius: 2px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);
            position: relative;
            text-align: left;
            letter-spacing: 0.3px;
        }
        
        .battle-btn:hover {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4) 0%, rgba(41, 128, 185, 0.4) 100%);
            border-left-color: rgba(52, 152, 219, 0.6);
            transform: translateX(2px);
        }
        
        .battle-btn:active {
            transform: translateX(1px);
        }
        
        .battle-btn.selected {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.4) 0%, rgba(211, 84, 0, 0.4) 100%);
            border-left-color: rgba(243, 156, 18, 0.8);
            border-left-width: 3px;
            transform: translateX(3px);
        }
        
        .battle-btn.selected::before {
            content: '▸ ';
            position: absolute;
            left: -12px;
            color: #f39c12;
            animation: pulse 0.8s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(0); }
            50% { opacity: 0.7; transform: translateX(-2px); }
        }
        
        /* Mobile Touch Controls */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            display: none;
            z-index: 150;
            pointer-events: none;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            #mobile-controls { display: block; }
            #controls { display: none; }
        }
        
        /* Responsive joystick sizing for different screens */
        @media (max-width: 480px) {
            .mobile-joystick {
                width: 100px;
                height: 100px;
            }
            #movement-joystick {
                bottom: 30px;
                left: 30px;
            }
            #camera-joystick {
                bottom: 30px;
                right: 30px;
            }
        }
        
        @media (min-width: 481px) and (max-width: 768px) {
            .mobile-joystick {
                width: 110px;
                height: 110px;
            }
        }
        
        /* Tablet landscape adjustments */
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
            #hud {
                font-size: 12px;
                padding: 12px;
            }
        }
        
        /* Large screen optimizations */
        @media (min-width: 1920px) {
            #hud {
                font-size: 16px;
                padding: 18px;
            }
        }
        
        /* Ultrawide screen adjustments */
        @media (min-aspect-ratio: 21/9) {
            #hud {
                left: 40px;
                top: 30px;
            }
            #battle-status {
                left: 40px;
            }
            #battle-ui {
                right: 40px;
            }
        }
        
        /* Portrait mobile adjustments */
        @media (max-width: 768px) and (orientation: portrait) {
            #battle-status {
                top: 60px;
                max-width: calc(100vw - 40px);
            }
            #battle-ui {
                bottom: 220px;
                max-width: calc(100vw - 40px);
            }
        }
        
        /* Landscape mobile adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #hud {
                top: 5px;
                left: 5px;
                font-size: 10px;
                padding: 8px;
            }
            #mobile-interact-btn {
                bottom: 140px;
            }
            .mobile-joystick {
                width: 90px;
                height: 90px;
            }
            #movement-joystick {
                bottom: 20px;
                left: 20px;
            }
            #camera-joystick {
                bottom: 20px;
                right: 20px;
            }
        }
        
        .mobile-joystick {
            position: absolute;
            width: 120px;
            height: 120px;
            pointer-events: all;
        }
        
        #movement-joystick {
            bottom: 40px;
            left: 40px;
        }
        
        #camera-joystick {
            bottom: 40px;
            right: 40px;
        }
        
        .joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(52, 73, 94, 0.7) 0%, rgba(44, 62, 80, 0.8) 100%);
            border: 3px solid rgba(149, 165, 166, 0.6);
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        
        .joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(243, 156, 18, 0.9) 0%, rgba(230, 126, 34, 1) 100%);
            border: 3px solid rgba(211, 84, 0, 0.9);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        #camera-joystick .joystick-stick {
            background: radial-gradient(circle, rgba(52, 152, 219, 0.9) 0%, rgba(41, 128, 185, 1) 100%);
            border-color: rgba(21, 67, 96, 0.9);
        }
        
        /* Mobile interaction button - only appears in Garden of Eden */
        #mobile-interact-btn {
            position: fixed;
            bottom: 180px;
            right: 50%;
            transform: translateX(50%);
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(46, 204, 113, 0.9) 0%, rgba(39, 174, 96, 1) 100%);
            border: 4px solid rgba(34, 153, 84, 0.9);
            border-radius: 50%;
            display: none; /* Hidden by default, only shown in Garden */
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 151;
            pointer-events: all;
        }
        #fullscreen-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(52, 152, 219, 0.8);
            border: 2px solid rgba(41, 128, 185, 0.9);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            cursor: pointer;
            z-index: 200;
            pointer-events: all;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        #fullscreen-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.1);
        }
        #fullscreen-btn:active {
            transform: scale(0.95);
        }
        @media (max-width: 768px) {
            #fullscreen-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 20px;
            text-align: center;
            box-sizing: border-box;
            overflow-y: auto;
        }
        #title-screen h1 {
            color: #f39c12;
            font-size: clamp(24px, 6vw, 36px);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #title-screen h2 {
            color: #9b59b6;
            font-size: clamp(16px, 4vw, 20px);
            margin-bottom: 30px;
        }
        #verse-display {
            max-width: 90%;
            width: 600px;
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            max-height: 50vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #verse-text {
            font-size: clamp(12px, 2.5vw, 14px);
            line-height: 1.6;
            color: #ecf0f1;
            margin-bottom: 10px;
            font-style: italic;
            text-align: left;
        }
        #verse-ref {
            color: #f39c12;
            font-size: clamp(11px, 2vw, 12px);
            font-weight: bold;
        }
        #start-button {
            background: #2ecc71;
            color: #fff;
            border: none;
            padding: clamp(12px, 3vw, 15px) clamp(30px, 8vw, 40px);
            font-size: clamp(16px, 4vw, 18px);
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #27ae60;
        }
        #start-button:hover {
            background: #27ae60;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #229954;
        }
        #start-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #229954;
        }
        #battle-ui {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: min(180px, 22vw);
            max-height: 20vh;
            background: linear-gradient(135deg, rgba(20, 20, 60, 0.05) 0%, rgba(10, 10, 40, 0.05) 100%);
            backdrop-filter: blur(2px);
            padding: 0;
            display: none;
            z-index: 150;
            border: 1px solid rgba(243, 156, 18, 0.3);
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
            font-family: 'Courier New', monospace;
            font-size: clamp(9px, 1.3vw, 11px);
            box-sizing: border-box;
        }
        
        @media (max-width: 768px) {
            #battle-ui {
                width: calc(100% - 20px);
                max-height: 20vh;
            }
        }
        
        #battle-status {
            position: fixed;
            top: 10px;
            right: 10px;
            width: min(160px, 20vw);
            max-height: 50vh;
            background: linear-gradient(135deg, rgba(20, 20, 60, 0.05) 0%, rgba(10, 10, 40, 0.05) 100%);
            backdrop-filter: blur(2px);
            padding: 0;
            display: none;
            z-index: 150;
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
            font-family: 'Courier New', monospace;
            font-size: clamp(8px, 1.2vw, 10px);
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            #battle-status {
                width: calc(100% - 20px);
                top: 10px;
                right: 10px;
                left: 10px;
                max-height: 20vh;
            }
        }
        
        .hero-status {
            display: flex;
            flex-direction: column;
            padding: clamp(4px, 0.8vw, 6px);
            background: rgba(0, 0, 0, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hero-status:last-child {
            border-bottom: none;
        }
        
        .hero-status.active {
            background: rgba(243, 156, 18, 0.1);
            border-left: 2px solid #f39c12;
        }
        
        .hero-name {
            font-weight: bold;
            color: #ecf0f1;
            font-size: clamp(10px, 1.5vw, 11px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);
            margin-bottom: 3px;
            letter-spacing: 0.5px;
        }
        
        .hero-status.active .hero-name {
            color: #f39c12;
        }
        
        .hero-stats {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        #enemy-status {
            display: none !important; /* Completely hidden - no enemy stats shown */
        }
        
        .enemy-status {
            padding: clamp(4px, 0.8vw, 6px);
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(231, 76, 60, 0.25);
        }
        
        .enemy-status:last-child {
            border-bottom: none;
        }
        
        .enemy-status.targeted {
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.3) 0%, rgba(243, 156, 18, 0.25) 100%);
            border-right: 3px solid #f39c12;
            box-shadow: inset 0 0 8px rgba(243, 156, 18, 0.25);
        }
        
        .enemy-name {
            font-weight: bold;
            color: #e74c3c;
            font-size: clamp(9px, 1.5vw, 11px);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            margin-bottom: 3px;
        }
        
        .enemy-status.targeted .enemy-name {
            color: #f39c12;
        }
        
        .status-bar {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 3px;
        }
        
        .status-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .hp-bar .status-fill { background: linear-gradient(90deg, #e74c3c, #c0392b); }
        .mp-bar .status-fill { background: linear-gradient(90deg, #3498db, #2980b9); }
        
        .battle-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .battle-btn {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9) 0%, rgba(44, 62, 80, 0.9) 100%);
            color: #ecf0f1;
            border: 1px solid rgba(149, 165, 166, 0.5);
            padding: 8px 12px;
            font-size: 11px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            text-align: left;
            position: relative;
        }
        
        .battle-btn:hover {
            background: linear-gradient(135deg, rgba(44, 62, 80, 0.95) 0%, rgba(52, 73, 94, 0.95) 100%);
            border-color: rgba(243, 156, 18, 0.8);
            transform: translateX(3px);
        }
        
        .battle-btn.selected {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.9) 0%, rgba(230, 126, 34, 0.9) 100%);
            border-color: #f39c12;
            color: #fff;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        .battle-btn::before {
            content: '▸ ';
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .battle-btn.selected::before {
            opacity: 1;
        }
        
        #battle-log {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            min-height: 40px;
            max-height: 60px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid rgba(149, 165, 166, 0.3);
        }
        
        .log-entry {
            margin: 3px 0;
            color: #ecf0f1;
            line-height: 1.3;
        }
        
        .log-entry:last-child {
            color: #f39c12;
        }
        #quote-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
            box-sizing: border-box;
        }
        #quote-box {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: clamp(20px, 4vw, 30px);
            max-width: 90%;
            width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-sizing: border-box;
        }
        #quote-text {
            font-size: clamp(12px, 2.5vw, 14px);
            line-height: 1.6;
        }
        #quote-continue {
            background: #f39c12;
            color: #1a252f;
            border: none;
            padding: clamp(10px, 2.5vw, 12px) clamp(25px, 6vw, 30px);
            font-size: clamp(14px, 3.5vw, 16px);
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            margin-top: 20px;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f39c12;
            font-size: clamp(18px, 5vw, 24px);
            z-index: 250;
            text-align: center;
            padding: 20px;
        }
    </style>
    <script>
        // Simple MIDI-style music system using Web Audio API
        let audioContext = null;
        let masterGainNode = null;
        let currentNotes = [];
        let musicPlaying = false;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = 0.15; // Low volume
                masterGainNode.connect(audioContext.destination);
            }
        }
        
        function playNote(frequency, duration, startTime) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            oscillator.type = 'sine'; // Soft, hymn-like tone
            oscillator.frequency.value = frequency;
            
            // ADSR envelope for organ-like sound
            const now = audioContext.currentTime + startTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.2, now + duration - 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
            
            oscillator.start(now);
            oscillator.stop(now + duration);
            
            currentNotes.push({ oscillator, gainNode });
        }
        
        // Original sacred hymn melody (not copyrighted)
        // Notes: C, D, E, F, G, A, B in various octaves
        const NOTE_FREQUENCIES = {
            C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, A4: 440.00, B4: 493.88,
            C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99, A5: 880.00, B5: 987.77
        };
        
        // Original sacred hymn composition
        const SACRED_HYMN = [
            // Measure 1-2: Opening phrase
            { note: 'C4', time: 0.0, duration: 0.8 },
            { note: 'E4', time: 0.8, duration: 0.8 },
            { note: 'G4', time: 1.6, duration: 1.2 },
            { note: 'F4', time: 2.8, duration: 0.4 },
            
            // Measure 3-4: Rising
            { note: 'E4', time: 3.2, duration: 0.8 },
            { note: 'F4', time: 4.0, duration: 0.8 },
            { note: 'G4', time: 4.8, duration: 1.6 },
            
            // Measure 5-6: Peak
            { note: 'C5', time: 6.4, duration: 0.8 },
            { note: 'B4', time: 7.2, duration: 0.4 },
            { note: 'A4', time: 7.6, duration: 0.4 },
            { note: 'G4', time: 8.0, duration: 1.2 },
            
            // Measure 7-8: Descent
            { note: 'F4', time: 9.2, duration: 0.8 },
            { note: 'E4', time: 10.0, duration: 0.8 },
            { note: 'D4', time: 10.8, duration: 1.2 },
            
            // Measure 9-10: Resolution
            { note: 'C4', time: 12.0, duration: 2.0 },
            
            // Measure 11-12: Second phrase
            { note: 'G4', time: 14.0, duration: 0.8 },
            { note: 'A4', time: 14.8, duration: 0.8 },
            { note: 'B4', time: 15.6, duration: 0.8 },
            { note: 'C5', time: 16.4, duration: 1.2 },
            
            // Measure 13-14: Development
            { note: 'D5', time: 17.6, duration: 0.4 },
            { note: 'C5', time: 18.0, duration: 0.4 },
            { note: 'B4', time: 18.4, duration: 0.4 },
            { note: 'A4', time: 18.8, duration: 0.4 },
            { note: 'G4', time: 19.2, duration: 1.6 },
            
            // Measure 15-16: Final phrase
            { note: 'E4', time: 20.8, duration: 0.8 },
            { note: 'F4', time: 21.6, duration: 0.8 },
            { note: 'G4', time: 22.4, duration: 0.8 },
            { note: 'C5', time: 23.2, duration: 2.4 }
        ];
        
        function playHymn() {
            if (!musicPlaying) return;
            
            initAudio();
            currentNotes = [];
            
            SACRED_HYMN.forEach(({ note, time, duration }) => {
                playNote(NOTE_FREQUENCIES[note], duration, time);
            });
            
            // Loop the hymn
            setTimeout(() => {
                if (musicPlaying) playHymn();
            }, 26000); // Total duration + small pause
        }
        
        function startMusic() {
            musicPlaying = true;
            initAudio();
            playHymn();
        }
        
        function stopMusic() {
            musicPlaying = false;
            currentNotes.forEach(({ oscillator }) => {
                try {
                    oscillator.stop();
                } catch (e) {}
            });
            currentNotes = [];
        }
    </script>
</head>
<body>
    <div id="loading">Loading 3D World...</div>
    
    <div id="title-screen">
        <h1>THE SEVEN HEAVENLY VIRTUES</h1>
        <h2>Battle Against Sin & Death - 3D Edition</h2>
        <div id="verse-display">
            <div id="verse-text"></div>
            <div id="verse-ref"></div>
        </div>
        <button id="start-button">Enter the Dungeon</button>
    </div>

    <div id="canvas-container"></div>
    
    <div id="crosshair"></div>
    
    <div id="hud">
        <div><strong>Level:</strong> <span id="level">1</span></div>
        <div><strong>Sins Defeated:</strong> <span id="sins">0</span>/7</div>
        <div><strong>Virtues:</strong> <span id="virtues">0</span>/7</div>
        <div><strong>Holy Water:</strong> <span id="water">3</span></div>
        <div><strong>Rosaries:</strong> <span id="rosary">2</span></div>
        <div><strong>Divine Elixirs:</strong> <span id="elixirs">0</span></div>
        <div><strong>Gold:</strong> <span id="gold">0</span></div>
    </div>

    <div id="message"></div>
    
    <div id="controls">
        <strong>WASD:</strong> Move | <strong>Click:</strong> Rotate camera | <strong>Walk into enemies to battle</strong>
    </div>
    
    <!-- Mobile Touch Controls -->
    <div id="mobile-controls">
        <div id="movement-joystick" class="mobile-joystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick"></div>
        </div>
        <div id="camera-joystick" class="mobile-joystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick"></div>
        </div>
    </div>
    
    <button id="mobile-interact-btn">INTERACT</button>
    <div id="fullscreen-btn" title="Toggle Fullscreen (F11)">⛶</div>

    <div id="battle-status"></div>
    <div id="enemy-status"></div>
    
    <div id="battle-ui">
        <div id="battle-log"></div>
        <div class="battle-actions" id="battle-actions"></div>
    </div>

    <div id="quote-overlay">
        <div id="quote-box">
            <div id="quote-text"></div>
            <div id="quote-author"></div>
            <button id="quote-continue">Continue Quest</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Constants
        const MOVE_SPEED = 13.5; // Reduced by 10% from 15 (15 * 0.9 = 13.5)
        const ROTATION_SPEED = 0.002;
        const MAP_SIZE = 40;
        const CELL_SIZE = 4;
        
        // Bible verses for title screen
        const titleScreenVerses = [
            { text: "No one has ascended into heaven except the one who descended from heaven, the Son of Man. And just as Moses lifted up the serpent in the wilderness, so must the Son of Man be lifted up, that whoever believes in him may have eternal life. For God so loved the world that he gave his only Son, so that everyone who believes in him may not perish but may have eternal life. Indeed, God did not send the Son into the world to condemn the world, but in order that the world might be saved through him. Those who believe in him are not condemned; but those who do not believe are condemned already, because they have not believed in the name of the only Son of God.", reference: "John 3:13-18" },
            { text: "Death has been swallowed up in victory. Where, O death, is your victory? Where, O death, is your sting? The sting of death is sin, and the power of sin is the law. But thanks be to God, who gives us the victory through our Lord Jesus Christ.", reference: "1 Corinthians 15:54-57" },
            { text: "For the wages of sin is death, but the gift of God is eternal life in Christ Jesus our Lord. What then are we to say? Should we continue in sin in order that grace may abound? By no means! How can we who died to sin go on living in it?", reference: "Romans 6:23-7:2" },
            { text: "Then I saw a new heaven and a new earth; for the first heaven and the first earth had passed away, and the sea was no more. And I saw the holy city, the new Jerusalem, coming down out of heaven from God, prepared as a bride adorned for her husband. And I heard a loud voice from the throne saying, 'See, the home of God is among mortals. He will dwell with them; they will be his peoples, and God himself will be with them; he will wipe every tear from their eyes. Death will be no more; mourning and crying and pain will be no more, for the first things have passed away.'", reference: "Revelation 21:1-4" }
        ];

        // Vice definitions
        const DEADLY_SINS = ['Pride', 'Greed', 'Lust', 'Envy', 'Gluttony', 'Wrath', 'Sloth'];
        const VICES = [
            { 
                name: "Pride", 
                minion: "Arrogance", 
                color: 0x9b59b6, 
                catechism: "Pride is excessive love of one's own excellence. It is contrary to the virtue of humility and was the sin of Lucifer. The Church teaches that pride is the beginning of all sin.", 
                verse: "Pride goes before destruction, a haughty spirit before a fall. Better to be lowly in spirit along with the oppressed than to share plunder with the proud. When pride comes, then comes disgrace, but with humility comes wisdom. The fear of the LORD teaches a man wisdom, and humility comes before honor.", 
                reference: "Proverbs 16:18-19, 11:2, 15:33" 
            },
            { 
                name: "Greed", 
                minion: "Avarice", 
                color: 0xf39c12, 
                catechism: "Greed is the immoderate desire for earthly goods and the power they bring. The Catechism warns against making money an idol and teaches us to trust in God's providence.", 
                verse: "The love of money is a root of all kinds of evil. Some people, eager for money, have wandered from the faith and pierced themselves with many griefs. No one can serve two masters. Either you will hate the one and love the other, or you will be devoted to the one and despise the other. You cannot serve both God and money. Keep your lives free from the love of money and be content with what you have, because God has said, 'Never will I leave you; never will I forsake you.'", 
                reference: "1 Timothy 6:10, Matthew 6:24, Hebrews 13:5" 
            },
            { 
                name: "Lust", 
                minion: "Desire", 
                color: 0xe91e63, 
                catechism: "Lust is disordered desire for sexual pleasure isolated from its unitive and procreative purposes. The Church calls us to chastity and purity of heart.", 
                verse: "Flee from sexual immorality. All other sins a person commits are outside the body, but whoever sins sexually, sins against their own body. Do you not know that your bodies are temples of the Holy Spirit, who is in you, whom you have received from God? You are not your own; you were bought at a price. Therefore honor God with your bodies. But among you there must not be even a hint of sexual immorality, or of any kind of impurity, because these are improper for God's holy people.", 
                reference: "1 Corinthians 6:18-20, Ephesians 5:3" 
            },
            { 
                name: "Envy", 
                minion: "Jealousy", 
                color: 0x27ae60, 
                catechism: "Envy is sadness at another's good fortune and the immoderate desire to acquire goods for oneself. It is contrary to the tenth commandment and leads to malice.", 
                verse: "A heart at peace gives life to the body, but envy rots the bones. Anger is cruel and fury overwhelming, but who can stand before jealousy? For where you have envy and selfish ambition, there you find disorder and every evil practice. Do not let your heart envy sinners, but always be zealous for the fear of the LORD.", 
                reference: "Proverbs 14:30, 27:4, James 3:16, Proverbs 23:17" 
            },
            { 
                name: "Gluttony", 
                minion: "Excess", 
                color: 0xe67e22, 
                catechism: "Gluttony is the immoderate desire for the pleasure of eating and drinking. The Church teaches moderation and self-control as fruits of the Holy Spirit.", 
                verse: "Do not join those who drink too much wine or gorge themselves on meat, for drunkards and gluttons become poor, and drowsiness clothes them in rags. Put a knife to your throat if you are given to gluttony. Their destiny is destruction, their god is their stomach, and their glory is in their shame. Their mind is set on earthly things. But our citizenship is in heaven.", 
                reference: "Proverbs 23:20-21, 23:2, Philippians 3:19-20" 
            },
            { 
                name: "Wrath", 
                minion: "Rage", 
                color: 0xc0392b, 
                catechism: "Anger becomes the sin of wrath when it is disproportionate to the offense and when it seeks revenge rather than justice. We are called to forgive as Christ forgave us.", 
                verse: "Get rid of all bitterness, rage and anger, brawling and slander, along with every form of malice. Be kind and compassionate to one another, forgiving each other, just as in Christ God forgave you. My dear brothers and sisters, take note of this: Everyone should be quick to listen, slow to speak and slow to become angry, because human anger does not produce the righteousness that God desires. Do not take revenge, but leave room for God's wrath.", 
                reference: "Ephesians 4:31-32, James 1:19-20, Romans 12:19" 
            },
            { 
                name: "Sloth", 
                minion: "Apathy", 
                color: 0x95a5a6, 
                catechism: "Sloth is spiritual laziness and neglect of divine grace. It shows itself in reluctance toward prayer, the sacraments, and works of charity.", 
                verse: "The sluggard's craving will be the death of him, because his hands refuse to work. How long will you lie there, you sluggard? When will you get up from your sleep? A little sleep, a little slumber, a little folding of the hands to rest—and poverty will come on you like a thief. Never be lacking in zeal, but keep your spiritual fervor, serving the Lord. Whatever you do, work at it with all your heart, as working for the Lord, not for human masters.", 
                reference: "Proverbs 21:25, 6:9-11, Romans 12:11, Colossians 3:23" 
            }
        ];

        const DEVIL_BOSS = {
            name: "The Devil",
            minion: "Demon",
            color: 0x8B0000,
            catechism: "The Devil and demons are fallen angels who rejected God. Through Christ's victory on the cross, Satan's power is broken. We must resist the devil through prayer, the sacraments, and faithful obedience to God.",
            verse: "The God of peace will soon crush Satan under your feet. The grace of our Lord Jesus be with you. Be alert and of sober mind. Your enemy the devil prowls around like a roaring lion looking for someone to devour. Resist him, standing firm in the faith. Submit yourselves to God. Resist the devil, and he will flee from you. The reason the Son of God appeared was to destroy the devil's work.",
            reference: "Romans 16:20, 1 Peter 5:8-9, James 4:7, 1 John 3:8"
        };

        const VIRTUE_ITEMS = {
            "Pride": { name: "Cloak of Humility", effect: "DEF +5", defBoost: 5 },
            "Lust": { name: "Chastity Belt Armor", effect: "HP +50", hpBoost: 50 },
            "Wrath": { name: "Shield of Patience", effect: "DEF +10", defBoost: 10 },
            "Greed": { name: "Sword of Charity", effect: "ATK +8", atkBoost: 8 },
            "Envy": { name: "Boots of Kindness", effect: "SPD +2", spdBoost: 2 },
            "Gluttony": { name: "Ring of Temperance", effect: "HP +30", hpBoost: 30 },
            "Sloth": { name: "Gauntlets of Diligence", effect: "ATK +5", atkBoost: 5 }
        };

        // Mythical Creatures - One unique creature per dungeon level (stats scale with level)
        const MYTHICAL_CREATURES = {
            1: {
                name: "Vampire",
                description: "An undead bloodsucker that haunts the night",
                color: 0x8B0000,
                baseHp: 80,
                baseAtk: 20,
                verse: "For the life of a creature is in the blood, and I have given it to you to make atonement for yourselves on the altar; it is the blood that makes atonement for one's life.",
                reference: "Leviticus 17:11"
            },
            2: {
                name: "Werewolf",
                description: "A cursed human that transforms into a beast",
                color: 0x654321,
                baseHp: 100,
                baseAtk: 25,
                verse: "Be alert and of sober mind. Your enemy the devil prowls around like a roaring lion looking for someone to devour. Resist him, standing firm in the faith.",
                reference: "1 Peter 5:8-9"
            },
            3: {
                name: "Ghost",
                description: "A tormented spirit that cannot rest",
                color: 0xE0E0E0,
                baseHp: 70,
                baseAtk: 18,
                verse: "For our struggle is not against flesh and blood, but against the rulers, against the authorities, against the powers of this dark world and against the spiritual forces of evil in the heavenly realms.",
                reference: "Ephesians 6:12"
            },
            4: {
                name: "Succubus",
                description: "A seductive demon that tempts the faithful",
                color: 0xFF1493,
                baseHp: 85,
                baseAtk: 22,
                verse: "Flee from sexual immorality. But among you there must not be even a hint of sexual immorality, or of any kind of impurity, or of greed, because these are improper for God's holy people.",
                reference: "1 Corinthians 6:18, Ephesians 5:3"
            },
            5: {
                name: "Sasquatch",
                description: "A mysterious wild beast of the forest",
                color: 0x8B4513,
                baseHp: 120,
                baseAtk: 28,
                verse: "Look at Behemoth, which I made along with you and which feeds on grass like an ox. What strength it has in its loins, what power in the muscles of its belly!",
                reference: "Job 40:15-16"
            },
            6: {
                name: "Yeti",
                description: "An abominable snowman from frozen peaks",
                color: 0xF0F8FF,
                baseHp: 110,
                baseAtk: 26,
                verse: "He spreads the snow like wool and scatters the frost like ashes. He hurls down his hail like pebbles. Who can withstand his icy blast?",
                reference: "Psalm 147:16-17"
            },
            7: {
                name: "Ogre",
                description: "A brutal giant that crushes its enemies",
                color: 0x556B2F,
                baseHp: 150,
                baseAtk: 35,
                verse: "The wicked freely strut about when what is vile is honored by the human race. There were giants on the earth in those days, and also afterward, when the sons of God came in to the daughters of men and they bore children to them.",
                reference: "Psalm 12:8, Genesis 6:4"
            }
        };

        // Special human evil - appears on Devil level
        const EPSTEIN_ENCOUNTER = {
            name: "Jeffrey Epstein",
            companion: "Ghislaine Maxwell",
            description: "A trafficker of innocence and embodiment of exploitation",
            color: 0xDC143C,
            auraColor: 0xFF0000,
            baseHp: 180,
            baseAtk: 40,
            companionHp: 140,
            companionAtk: 32,
            verse: "But whoso shall offend one of these little ones which believe in me, it were better for him that a millstone were hanged about his neck, and that he were drowned in the depth of the sea. Woe unto the world because of offences! If your hand or foot causes you to stumble, cut it off and throw it away. It is better for you to enter life maimed or crippled than to have two hands or two feet and be thrown into eternal fire.",
            reference: "Matthew 18:6-8"
        };

        // Mythical Creature Stat Boosts - Special permanent upgrades for defeating each creature
        const MYTHICAL_REWARDS = {
            "Vampire": {
                name: "God's Blessing Against the Vampire",
                description: "Through God's grace, you have vanquished the undead. This divine blessing strengthens your body and draws you closer to the Lord's eternal life.",
                hpBoost: 25,
                effect: "All Heroes: +25 Max HP"
            },
            "Werewolf": {
                name: "God's Blessing Against the Werewolf",
                description: "The Lord has delivered you from the beast's curse. His blessing empowers your righteous strikes and brings you closer to His divine strength.",
                atkBoost: 5,
                effect: "All Heroes: +5 ATK"
            },
            "Ghost": {
                name: "God's Blessing Against the Ghost",
                description: "God's protection shields you from the wandering spirit. This blessing fortifies your faith and draws you closer to His eternal peace.",
                defBoost: 5,
                effect: "All Heroes: +5 DEF"
            },
            "Succubus": {
                name: "God's Blessing Against the Succubus",
                description: "Through purity and prayer, you resisted temptation. God's blessing strengthens your resolve and brings you closer to His holy presence.",
                hpBoost: 20,
                defBoost: 3,
                effect: "All Heroes: +20 Max HP, +3 DEF"
            },
            "Sasquatch": {
                name: "God's Blessing Against the Sasquatch",
                description: "The Lord granted you victory over the wild beast. His blessing channels divine power through you and draws you closer to His mighty hand.",
                atkBoost: 7,
                hpBoost: 15,
                effect: "All Heroes: +7 ATK, +15 Max HP"
            },
            "Yeti": {
                name: "God's Blessing Against the Yeti",
                description: "God's warmth has melted the frozen terror. This divine blessing fortifies your spirit and brings you closer to His enduring love.",
                hpBoost: 30,
                defBoost: 5,
                effect: "All Heroes: +30 Max HP, +5 DEF"
            },
            "Ogre": {
                name: "God's Blessing Against the Ogre",
                description: "With God's might, you felled the giant. His blessing empowers you with holy strength and draws you closer to His infinite power.",
                atkBoost: 10,
                hpBoost: 20,
                defBoost: 5,
                effect: "All Heroes: +10 ATK, +20 Max HP, +5 DEF"
            },
            "Jeffrey Epstein": {
                name: "God's Blessing for Defending the Innocent",
                description: "The Lord rewards those who protect His children from evil. This divine blessing strengthens your righteousness and brings you closer to God's perfect justice.",
                atkBoost: 8,
                defBoost: 8,
                hpBoost: 40,
                effect: "All Heroes: +8 ATK, +8 DEF, +40 Max HP"
            }
        };

        // Dungeon Themes - Different visual style for each level
        const DUNGEON_THEMES = {
            1: { 
                name: "Blood Crypt",
                wallColor: 0x8B0000, 
                floorColor: 0x4B0000, 
                ceilingColor: 0x2B0000,
                ambientColor: 0xFF0000,
                decoration: 'torches'
            },
            2: { 
                name: "Beast's Lair",
                wallColor: 0x654321, 
                floorColor: 0x3E2723, 
                ceilingColor: 0x4E342E,
                ambientColor: 0xD2691E,
                decoration: 'torches'
            },
            3: { 
                name: "Haunted Halls",
                wallColor: 0x708090, 
                floorColor: 0x2F4F4F, 
                ceilingColor: 0x778899,
                ambientColor: 0xE0E0E0,
                decoration: 'crystals'
            },
            4: { 
                name: "Temptation Chamber",
                wallColor: 0x8B008B, 
                floorColor: 0x4B0049, 
                ceilingColor: 0x6B0063,
                ambientColor: 0xFF1493,
                decoration: 'crystals'
            },
            5: { 
                name: "Primeval Forest",
                wallColor: 0x556B2F, 
                floorColor: 0x3D5229, 
                ceilingColor: 0x6B8E23,
                ambientColor: 0x9ACD32,
                decoration: 'crystals'
            },
            6: { 
                name: "Frozen Depths",
                wallColor: 0x4682B4, 
                floorColor: 0x1E3A5F, 
                ceilingColor: 0x5F9EA0,
                ambientColor: 0x87CEEB,
                decoration: 'crystals'
            },
            7: { 
                name: "Infernal Throne",
                wallColor: 0xFF4500, 
                floorColor: 0x8B0000, 
                ceilingColor: 0xDC143C,
                ambientColor: 0xFF6347,
                decoration: 'torches'
            }
        };

        // Game state
        let scene, camera, renderer, raycaster, mouse, playerModel;
        let dungeon = [];
        let enemies = [];
        let pickups = [];
        let gameState = 'title';
        let dungeonLevel = 1;
        let defeatedSins = new Set();
        let defeatedMythicalCreatures = new Set(); // Track which mythical creatures have been defeated
        
        const inventory = {
            holyWater: 3,
            rosaries: 2,
            gold: 0,
            atkBoost: 0,
            defBoost: 0,
            hpBoost: 0,
            virtueItems: [],
            divineElixirs: 0  // Full party HP & MP restore
        };

        const heroes = [
            { 
                name: "St. Vincent", 
                hp: 100, 
                maxHp: 100, 
                mp: 30, 
                maxMp: 30, 
                atk: 15, 
                def: 8,
                specialAttack: "Rosary Throw",
                specialCost: 15,
                specialDamage: 40
            },
            { 
                name: "St. Michael", 
                hp: 120, 
                maxHp: 120, 
                mp: 25, 
                maxMp: 25, 
                atk: 18, 
                def: 6,
                specialAttack: "Heavenly Host",
                specialCost: 20,
                specialDamage: 50
            },
            { 
                name: "St. Joan", 
                hp: 110, 
                maxHp: 110, 
                mp: 35, 
                maxMp: 35, 
                atk: 14, 
                def: 10,
                specialAttack: "Divine Charge",
                specialCost: 15,
                specialDamage: 45
            }
        ];
        
        // New Game+ Divine Party
        let newGamePlus = false;
        const divineHeroes = [
            {
                name: "Jesus Christ",
                hp: 999,
                maxHp: 999,
                mp: 999,
                maxMp: 999,
                atk: 9999, // Greater than any enemy HP
                def: 999,
                specialAttack: "Divine Wrath",
                specialCost: 0,
                specialDamage: 9999
            },
            {
                name: "Padre Pio",
                hp: 500,
                maxHp: 500,
                mp: 200,
                maxMp: 200,
                atk: 100,
                def: 80,
                specialAttack: "Stigmata",
                specialCost: 50,
                specialDamage: 500
            },
            {
                name: "St. Vincent Ferrer",
                hp: 600,
                maxHp: 600,
                mp: 250,
                maxMp: 250,
                atk: 150,
                def: 100,
                specialAttack: "Judgment",
                specialCost: 75,
                specialDamage: 9999, // Instant kill
                hasWings: true
            },
            {
                name: "Mother Mary",
                hp: 800,
                maxHp: 800,
                mp: 300,
                maxMp: 300,
                atk: 120,
                def: 150,
                specialAttack: "Hail Mary",
                specialCost: 50,
                specialDamage: 9999, // Instant kill
                isMary: true
            }
        ];
        
        // Get current hero party based on mode
        function getCurrentHeroes() {
            return newGamePlus ? divineHeroes : heroes;
        }
        
        // Switch to divine party (replaces heroes array content)
        function enableDivineParty() {
            // Copy divine heroes into heroes array
            heroes.length = 0;
            divineHeroes.forEach(hero => {
                heroes.push({...hero}); // Clone the hero
            });
        }

        let battle = {
            active: false,
            enemies: [],
            currentHeroIndex: 0,
            targetIndex: 0,
            log: [],
            phase: 'menu'
        };

        // Controls
        const keys = {};
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;
        let targetRotationY = 0; // Target camera rotation for click-to-move
        
        // Mobile touch controls
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let movementJoystick = { active: false, startX: 0, startY: 0, deltaX: 0, deltaY: 0 };
        let cameraJoystick = { active: false, startX: 0, startY: 0, deltaX: 0, deltaY: 0 };
        let nearestInteractable = null;

        // Three.js setup
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Bright sky blue
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.015); // Exponential fog for atmospheric depth

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 5); // Start further back for better initial view

            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Enable physically-based rendering for cinematic quality
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting - Cinematic dramatic lighting
            const ambientLight = new THREE.AmbientLight(0x4a4a6a, 0.3);
            scene.add(ambientLight);

            // Main key light - warm dramatic lighting from above
            const directionalLight = new THREE.DirectionalLight(0xffaa66, 3.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.bias = -0.0005;
            directionalLight.shadow.radius = 2;
            scene.add(directionalLight);
            
            // Atmospheric hemisphere light for depth
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x2a2a3a, 0.5);
            scene.add(hemisphereLight);

            // Player torch light - warm orange glow
            const pointLight = new THREE.PointLight(0xffaa44, 2.0, 20, 2);
            pointLight.position.copy(camera.position);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 1024;
            pointLight.shadow.mapSize.height = 1024;
            pointLight.shadow.bias = -0.001;
            scene.add(pointLight);
            camera.userData.light = pointLight;
            
            // Add subtle rim light for edge definition
            const rimLight = new THREE.DirectionalLight(0x6699ff, 0.8);
            rimLight.position.set(-10, 5, -10);
            scene.add(rimLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('orientationchange', onOrientationChange);
            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange); // Safari
            document.addEventListener('msfullscreenchange', onFullscreenChange); // IE11
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            
            // F11 key for fullscreen toggle
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleFullscreen();
                }
            });
            
            // No pointer lock for click-to-move camera

            // Title screen
            displayVerse(0);
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('loading').style.display = 'none';
            
            // Setup mobile controls if on mobile device
            if (isMobile) {
                setupMobileControls();
            }
        }

        function setupMobileControls() {
            // Movement joystick (left)
            const movementStick = document.querySelector('#movement-joystick .joystick-stick');
            const movementBase = document.querySelector('#movement-joystick .joystick-base');
            
            movementBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                movementJoystick.active = true;
                const touch = e.touches[0];
                const rect = movementBase.getBoundingClientRect();
                movementJoystick.startX = rect.left + rect.width / 2;
                movementJoystick.startY = rect.top + rect.height / 2;
            });
            
            movementBase.addEventListener('touchmove', (e) => {
                if (!movementJoystick.active) return;
                e.preventDefault();
                const touch = e.touches[0];
                const deltaX = touch.clientX - movementJoystick.startX;
                const deltaY = touch.clientY - movementJoystick.startY;
                const distance = Math.min(35, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);
                
                movementJoystick.deltaX = (distance * Math.cos(angle)) / 35;
                movementJoystick.deltaY = (distance * Math.sin(angle)) / 35;
                
                movementStick.style.transform = `translate(calc(-50% + ${distance * Math.cos(angle)}px), calc(-50% + ${distance * Math.sin(angle)}px))`;
            });
            
            movementBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                movementJoystick.active = false;
                movementJoystick.deltaX = 0;
                movementJoystick.deltaY = 0;
                movementStick.style.transform = 'translate(-50%, -50%)';
            });
            
            // Camera joystick (right)
            const cameraStick = document.querySelector('#camera-joystick .joystick-stick');
            const cameraBase = document.querySelector('#camera-joystick .joystick-base');
            
            cameraBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                cameraJoystick.active = true;
                const touch = e.touches[0];
                const rect = cameraBase.getBoundingClientRect();
                cameraJoystick.startX = rect.left + rect.width / 2;
                cameraJoystick.startY = rect.top + rect.height / 2;
            });
            
            cameraBase.addEventListener('touchmove', (e) => {
                if (!cameraJoystick.active) return;
                e.preventDefault();
                const touch = e.touches[0];
                const deltaX = touch.clientX - cameraJoystick.startX;
                const deltaY = touch.clientY - cameraJoystick.startY;
                const distance = Math.min(35, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);
                
                cameraJoystick.deltaX = (distance * Math.cos(angle)) / 35;
                cameraJoystick.deltaY = (distance * Math.sin(angle)) / 35;
                
                cameraStick.style.transform = `translate(calc(-50% + ${distance * Math.cos(angle)}px), calc(-50% + ${distance * Math.sin(angle)}px))`;
            });
            
            cameraBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                cameraJoystick.active = false;
                cameraJoystick.deltaX = 0;
                cameraJoystick.deltaY = 0;
                cameraStick.style.transform = 'translate(-50%, -50%)';
            });
            
            // Mobile interact button
            document.getElementById('mobile-interact-btn').addEventListener('click', (e) => {
                e.preventDefault();
                if (gameState === 'garden' && nearestInteractable) {
                    showGardenDialog(nearestInteractable.type, nearestInteractable);
                }
            });
            
            // Fullscreen button
            document.getElementById('fullscreen-btn').addEventListener('click', (e) => {
                e.preventDefault();
                toggleFullscreen();
            });
        }
        
        function setupTouchControls() {
            const joystickBase = document.getElementById('joystick-base');
            const joystickStick = document.getElementById('joystick-stick');
            const lookBase = document.getElementById('look-base');
            const lookStick = document.getElementById('look-stick');
            
            // Movement joystick
            joystickBase.addEventListener('touchstart', (e) => {
                if (gameState !== 'explore') return;
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                const rect = joystickBase.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
            });
            
            joystickBase.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                const deltaX = touch.clientX - joystickStartX;
                const deltaY = touch.clientY - joystickStartY;
                const distance = Math.min(35, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);
                
                joystickCurrentX = distance * Math.cos(angle) / 35;
                joystickCurrentY = distance * Math.sin(angle) / 35;
                
                joystickStick.style.transform = `translate(calc(-50% + ${distance * Math.cos(angle)}px), calc(-50% + ${distance * Math.sin(angle)}px))`;
            });
            
            joystickBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickCurrentX = 0;
                joystickCurrentY = 0;
                joystickStick.style.transform = 'translate(-50%, -50%)';
            });
            
            // Camera D-pad (discrete up/down/left/right for camera)
            lookBase.addEventListener('touchstart', (e) => {
                if (gameState !== 'explore') return;
                e.preventDefault();
                lookActive = true;
                updateLookDirection(e.touches[0]);
            });
            
            lookBase.addEventListener('touchmove', (e) => {
                if (!lookActive) return;
                e.preventDefault();
                updateLookDirection(e.touches[0]);
            });
            
            lookBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                lookActive = false;
                lookDeltaX = 0;
                lookDeltaY = 0;
                lookStick.style.transform = 'translate(-50%, -50%)';
            });
            
            function updateLookDirection(touch) {
                const rect = lookBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > 15) { // Dead zone
                    // Snap to 4 directions (D-pad style)
                    let snapX = 0, snapY = 0;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Left or Right
                        if (deltaX > 0) {
                            snapX = 35; // Right
                            lookDeltaX = 1;
                            lookDeltaY = 0;
                        } else {
                            snapX = -35; // Left
                            lookDeltaX = -1;
                            lookDeltaY = 0;
                        }
                    } else {
                        // Up or Down
                        if (deltaY > 0) {
                            snapY = 35; // Down
                            lookDeltaX = 0;
                            lookDeltaY = 1;
                        } else {
                            snapY = -35; // Up
                            lookDeltaX = 0;
                            lookDeltaY = -1;
                        }
                    }
                    
                    lookStick.style.transform = `translate(calc(-50% + ${snapX}px), calc(-50% + ${snapY}px))`;
                } else {
                    lookDeltaX = 0;
                    lookDeltaY = 0;
                    lookStick.style.transform = 'translate(-50%, -50%)';
                }
            }
        }

        function displayVerse(index) {
            const verse = titleScreenVerses[index % titleScreenVerses.length];
            document.getElementById('verse-text').textContent = verse.text;
            document.getElementById('verse-ref').textContent = `— ${verse.reference}`;
        }

        function startGame() {
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block'; // Show HUD
            gameState = 'explore';
            createVisiblePlayerModel(); // Create third-person player model
            generateDungeon();
            
            // Position camera behind player model
            if (playerModel) {
                camera.position.set(
                    playerModel.position.x,
                    playerModel.position.y + 3,
                    playerModel.position.z + 5
                );
                camera.lookAt(playerModel.position.x, playerModel.position.y + 1, playerModel.position.z);
            }
            
            targetRotationY = camera.rotation.y;
            updateHUD(); // Update HUD with initial values
            startMusic(); // Start sacred music
        }

        function createVisiblePlayerModel() {
            // Remove existing player model if it exists
            if (playerModel) {
                try {
                    scene.remove(playerModel);
                } catch (e) {
                    console.log('Error removing old player model:', e);
                }
            }
            
            try {
                // Use St. Vincent Ferrer in regular mode, Jesus in New Game+
                if (newGamePlus) {
                    playerModel = createJesusModel();
                } else {
                    playerModel = createStVincentModel();
                }
                
                if (playerModel) {
                    playerModel.position.set(0, 0, 0);
                    playerModel.castShadow = true;
                    playerModel.receiveShadow = true;
                    scene.add(playerModel);
                }
            } catch (e) {
                console.log('Error creating player model:', e);
                playerModel = null;
            }
        }

        function createPlayerModel() {
            // In New Game+ mode, use Jesus model
            if (newGamePlus) {
                return createJesusModel();
            }
            
            const group = new THREE.Group();
            
            // Body (dark blue tunic with PBR materials)
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.7, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                roughness: 0.8,
                metalness: 0.1,
                envMapIntensity: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Head (realistic skin tone with subsurface scattering simulation)
            const headGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0c291,
                roughness: 0.6,
                metalness: 0.0,
                envMapIntensity: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.0;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // Hair (brown with texture variation)
            const hairGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.4);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3e2723,
                roughness: 0.9,
                metalness: 0.0
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.15;
            hair.castShadow = true;
            group.add(hair);
            
            // Eyes (glossy)
            const eyeGeometry = new THREE.SphereGeometry(0.04, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x5d4037,
                roughness: 0.1,
                metalness: 0.0,
                emissive: 0x5d4037,
                emissiveIntensity: 0.1
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.0, 0.18);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.0, 0.18);
            group.add(leftEye);
            group.add(rightEye);
            
            // Legs (brown cloth material)
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.4, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8d6e63,
                roughness: 0.9,
                metalness: 0.0
            });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.1, 0);
            leftLeg.castShadow = true;
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.1, 0);
            rightLeg.castShadow = true;
            group.add(leftLeg);
            group.add(rightLeg);
            
            return group;
        }

        function createStMichaelModel() {
            const group = new THREE.Group();
            
            // Wings (white)
            const wingGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.1);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.4, 0.6, 0);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.4, 0.6, 0);
            group.add(leftWing);
            group.add(rightWing);
            
            // Body (blue robe)
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.7, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.0;
            group.add(head);
            
            // Hair (brown)
            const hairGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.25;
            group.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.05);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.0, 0.2);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.0, 0.2);
            group.add(leftEye);
            group.add(rightEye);
            
            // Halo (gold ring)
            const haloGeometry = new THREE.TorusGeometry(0.3, 0.03, 8, 16);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf39c12,
                emissive: 0xf39c12,
                emissiveIntensity: 0.5
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 1.4;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            // Sword (silver)
            const swordGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
            const swordMaterial = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.position.set(0.4, 0.5, 0);
            group.add(sword);
            
            // Shield (red)
            const shieldGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.1);
            const shieldMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.set(-0.5, 0.5, 0);
            group.add(shield);
            
            // Shield cross (gold)
            const crossGeometry = new THREE.BoxGeometry(0.15, 0.05, 0.05);
            const crossMaterial = new THREE.MeshStandardMaterial({ color: 0xf39c12 });
            const crossH = new THREE.Mesh(crossGeometry, crossMaterial);
            crossH.position.set(-0.5, 0.5, 0.1);
            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.05), crossMaterial);
            crossV.position.set(-0.5, 0.5, 0.1);
            group.add(crossH);
            group.add(crossV);
            
            // Legs (dark blue)
            const legGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.1, 0);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.1, 0);
            group.add(leftLeg);
            group.add(rightLeg);
            
            return group;
        }

        function createStJoanModel() {
            const group = new THREE.Group();
            
            // Body (silver armor)
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.7, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x95a5a6,
                metalness: 0.6,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            group.add(body);
            
            // Armor detail (lighter silver)
            const armorDetailGeometry = new THREE.BoxGeometry(0.15, 0.3, 0.41);
            const armorDetailMaterial = new THREE.MeshStandardMaterial({ color: 0xbdc3c7 });
            const armorDetail = new THREE.Mesh(armorDetailGeometry, armorDetailMaterial);
            armorDetail.position.set(-0.2, 0.55, 0);
            group.add(armorDetail);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.0;
            group.add(head);
            
            // Hair (brown)
            const hairGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.4);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.2;
            group.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.05);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.0, 0.2);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.0, 0.2);
            group.add(leftEye);
            group.add(rightEye);
            
            // Banner/Flag pole (brown)
            const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.0, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0.4, 0.7, 0);
            group.add(pole);
            
            // Banner flag (red)
            const flagGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.05);
            const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.5, 1.1, 0);
            group.add(flag);
            
            // Legs (gray armor)
            const legGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.1, 0);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.1, 0);
            group.add(leftLeg);
            group.add(rightLeg);
            
            return group;
        }

        function createStVincentModel() {
            const group = new THREE.Group();
            
            // Black Dominican robe (main body)
            const robeGeometry = new THREE.BoxGeometry(0.8, 1.3, 0.5);
            const robeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.85,
                metalness: 0.1
            });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.75;
            robe.castShadow = true;
            group.add(robe);
            
            // White scapular (over robe)
            const scapularGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.52);
            const scapularMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.9 
            });
            const scapular = new THREE.Mesh(scapularGeometry, scapularMaterial);
            scapular.position.y = 0.75;
            scapular.castShadow = true;
            group.add(scapular);
            
            // Hood
            const hoodGeometry = new THREE.ConeGeometry(0.3, 0.4, 8);
            const hoodMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.85
            });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.y = 1.8;
            hood.rotation.x = Math.PI;
            group.add(hood);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            group.add(head);
            
            // GLOWING HALO
            const haloGeometry = new THREE.TorusGeometry(0.35, 0.05, 8, 32);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffeb3b,
                emissive: 0xffeb3b,
                emissiveIntensity: 1.5,
                metalness: 0.5,
                roughness: 0.3
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 2;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            // Halo light
            const haloLight = new THREE.PointLight(0xffeb3b, 0.5, 3);
            haloLight.position.set(0, 2, 0);
            group.add(haloLight);
            
            // Cross necklace
            const crossVertical = new THREE.BoxGeometry(0.05, 0.2, 0.05);
            const crossHorizontal = new THREE.BoxGeometry(0.15, 0.05, 0.05);
            const crossMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4af37,
                metalness: 0.8,
                roughness: 0.2
            });
            const crossV = new THREE.Mesh(crossVertical, crossMaterial);
            crossV.position.set(0, 1.2, 0.3);
            const crossH = new THREE.Mesh(crossHorizontal, crossMaterial);
            crossH.position.set(0, 1.25, 0.3);
            group.add(crossV);
            group.add(crossH);
            
            // Rope belt
            const beltGeometry = new THREE.TorusGeometry(0.35, 0.03, 8, 16);
            const beltMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 0.5;
            belt.rotation.x = Math.PI / 2;
            group.add(belt);
            
            // Legs/feet
            const legGeometry = new THREE.CylinderGeometry(0.12, 0.10, 0.5, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.85
            });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.15, 0);
            leftLeg.castShadow = true;
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.15, 0);
            rightLeg.castShadow = true;
            group.add(leftLeg);
            group.add(rightLeg);
            
            return group;
        }

        function createViceModel(vice) {
            const group = new THREE.Group();
            const color = vice.color;
            
            // Body with detailed muscular definition
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
            // Add vertex displacement for muscle definition
            const positions = bodyGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const noise = Math.sin(x * 5) * Math.cos(y * 5) * 0.05;
                positions.setX(i, x + noise);
                positions.setZ(i, positions.getZ(i) + noise);
            }
            positions.needsUpdate = true;
            bodyGeometry.computeVertexNormals();
            
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.4,
                roughness: 0.7,
                metalness: 0.2,
                envMapIntensity: 0.6
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Head with more detail
            const headGeometry = new THREE.DodecahedronGeometry(0.4, 1);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: vice.name === "The Devil" ? 0xCD0000 : 0x8b6f47,
                roughness: 0.8,
                metalness: 0.1,
                envMapIntensity: 0.4
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // Eyes (glowing intensely)
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: vice.name === "The Devil" ? 0xffff00 : 0xff4400,
                emissive: vice.name === "The Devil" ? 0xffff00 : 0xff4400,
                emissiveIntensity: 2.0,
                roughness: 0.1,
                metalness: 0.0
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 1.6, 0.3);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 1.6, 0.3);
            group.add(leftEye);
            group.add(rightEye);
            
            // Add glowing point lights for eyes
            const leftEyeLight = new THREE.PointLight(
                vice.name === "The Devil" ? 0xffff00 : 0xff4400, 
                0.5, 
                3
            );
            leftEyeLight.position.copy(leftEye.position);
            group.add(leftEyeLight);
            
            const rightEyeLight = new THREE.PointLight(
                vice.name === "The Devil" ? 0xffff00 : 0xff4400, 
                0.5, 
                3
            );
            rightEyeLight.position.copy(rightEye.position);
            group.add(rightEyeLight);
            
            // Special features for specific sins with enhanced materials
            if (vice.name === "Pride") {
                // Crown (highly reflective gold)
                const crownGeometry = new THREE.BoxGeometry(0.7, 0.2, 0.6);
                const crownMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700,
                    emissive: 0xffd700,
                    emissiveIntensity: 0.6,
                    roughness: 0.2,
                    metalness: 0.9
                });
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.y = 2.0;
                crown.castShadow = true;
                group.add(crown);
                
                // Crown spikes with glow
                for (let i = -1; i <= 1; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.08, 0.3, 8);
                    const spike = new THREE.Mesh(spikeGeometry, crownMaterial);
                    spike.position.set(i * 0.25, 2.25, 0);
                    spike.castShadow = true;
                    group.add(spike);
                }
            } else if (vice.name === "Greed") {
                // Money bag with realistic cloth
                const bagGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                bagGeometry.scale(1, 1.3, 1);
                const bagMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.95,
                    metalness: 0.0
                });
                const bag = new THREE.Mesh(bagGeometry, bagMaterial);
                bag.position.set(-0.6, 0.8, 0);
                bag.castShadow = true;
                group.add(bag);
                
                // Gold coins with high metalness
                const coinGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 32);
                const coinMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700,
                    roughness: 0.15,
                    metalness: 0.95,
                    emissive: 0xffd700,
                    emissiveIntensity: 0.3
                });
                for (let i = 0; i < 3; i++) {
                    const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                    coin.position.set(-0.6 + i * 0.1, 1.0 + i * 0.08, 0.1 + i * 0.05);
                    coin.castShadow = true;
                    group.add(coin);
                }
            } else if (vice.name === "The Devil") {
                // Horns with dark red glow
                const hornGeometry = new THREE.ConeGeometry(0.1, 0.4, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a0000,
                    roughness: 0.6,
                    metalness: 0.4,
                    emissive: 0x8B0000,
                    emissiveIntensity: 0.5
                });
                const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                leftHorn.position.set(-0.25, 2.1, 0);
                leftHorn.rotation.z = -Math.PI / 6;
                leftHorn.castShadow = true;
                const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                rightHorn.position.set(0.25, 2.1, 0);
                rightHorn.rotation.z = Math.PI / 6;
                rightHorn.castShadow = true;
                group.add(leftHorn);
                group.add(rightHorn);
                
                // Tail with segments
                for (let i = 0; i < 5; i++) {
                    const segmentGeometry = new THREE.SphereGeometry(0.08 - i * 0.01, 8, 8);
                    const segmentMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B0000,
                        roughness: 0.8,
                        metalness: 0.2,
                        emissive: 0x4a0000,
                        emissiveIntensity: 0.3
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.set(
                        0.3 + i * 0.1,
                        0.6 - i * 0.15,
                        -0.3 - i * 0.1
                    );
                    segment.castShadow = true;
                    group.add(segment);
                }
            }
            
            // Legs with muscle definition
            const legGeometry = new THREE.CylinderGeometry(0.12, 0.10, 0.5, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                roughness: 0.85,
                metalness: 0.1
            });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.15, 0);
            leftLeg.castShadow = true;
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.15, 0);
            rightLeg.castShadow = true;
            group.add(leftLeg);
            group.add(rightLeg);
            
            return group;
        }
        
        function createPadrePioModel() {
            const group = new THREE.Group();
            
            // Brown Franciscan robe
            const robeGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x6B4423, roughness: 0.9 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.7;
            robe.castShadow = true;
            group.add(robe);
            
            // Head with beard
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            group.add(head);
            
            // Stigmata wounds on hands (red glowing spheres)
            const stigmataGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const stigmataMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            const leftStigmata = new THREE.Mesh(stigmataGeometry, stigmataMaterial);
            leftStigmata.position.set(-0.5, 0.9, 0.3);
            group.add(leftStigmata);
            
            const rightStigmata = new THREE.Mesh(stigmataGeometry, stigmataMaterial);
            rightStigmata.position.set(0.5, 0.9, 0.3);
            group.add(rightStigmata);
            
            // Rosary beads
            const beadGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const beadMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            for (let i = 0; i < 10; i++) {
                const bead = new THREE.Mesh(beadGeometry, beadMaterial);
                const angle = (i / 10) * Math.PI;
                bead.position.set(Math.sin(angle) * 0.25, 0.3 - i * 0.05, 0.25);
                group.add(bead);
            }
            
            return group;
        }
        
        function createStVincentFerrerModel() {
            const group = new THREE.Group();
            
            // Black Dominican robe
            const robeGeometry = new THREE.BoxGeometry(0.8, 1.3, 0.5);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.85 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.75;
            robe.castShadow = true;
            group.add(robe);
            
            // White scapular
            const scapularGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.52);
            const scapularMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            const scapular = new THREE.Mesh(scapularGeometry, scapularMaterial);
            scapular.position.y = 0.75;
            group.add(scapular);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            group.add(head);
            
            // Glowing halo
            const haloGeometry = new THREE.TorusGeometry(0.35, 0.05, 8, 32);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffeb3b,
                emissive: 0xffeb3b,
                emissiveIntensity: 1.5
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 2;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            return group;
        }
        
        function createMotherMaryModel() {
            const group = new THREE.Group();
            
            // Blue mantle
            const mantleGeometry = new THREE.BoxGeometry(0.9, 1.4, 0.5);
            const mantleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1e40af,
                roughness: 0.6,
                metalness: 0.2
            });
            const mantle = new THREE.Mesh(mantleGeometry, mantleMaterial);
            mantle.position.y = 0.8;
            mantle.castShadow = true;
            group.add(mantle);
            
            // White inner robe
            const robeGeometry = new THREE.BoxGeometry(0.7, 1.2, 0.48);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.75;
            group.add(robe);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.23, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            group.add(head);
            
            // Veil
            const veilGeometry = new THREE.ConeGeometry(0.35, 0.5, 16);
            const veilMaterial = new THREE.MeshStandardMaterial({ color: 0x1e40af, roughness: 0.7 });
            const veil = new THREE.Mesh(veilGeometry, veilMaterial);
            veil.position.y = 1.9;
            veil.rotation.y = Math.PI;
            group.add(veil);
            
            // Golden halo
            const haloGeometry = new THREE.TorusGeometry(0.35, 0.05, 8, 32);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 1.2,
                metalness: 0.8,
                roughness: 0.2
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 2.1;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            // Rosary in hands
            const rosaryGeometry = new THREE.TorusGeometry(0.15, 0.03, 8, 24);
            const rosaryMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const rosary = new THREE.Mesh(rosaryGeometry, rosaryMaterial);
            rosary.position.set(0, 0.5, 0.3);
            rosary.rotation.x = Math.PI / 3;
            group.add(rosary);
            
            // Soft glow around Mary
            const glowLight = new THREE.PointLight(0xffffff, 0.5, 3);
            glowLight.position.set(0, 1, 0);
            group.add(glowLight);
            
            return group;
        }

        function generateDungeon(spawnDevilBoss = false) {
            // Clear existing dungeon
            while(scene.children.length > 0) { 
                const obj = scene.children[0];
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                scene.remove(obj);
            }

            // Get theme for current dungeon level
            const theme = DUNGEON_THEMES[dungeonLevel] || DUNGEON_THEMES[7];

            // Theme-based lighting
            const ambientLight = new THREE.AmbientLight(theme.ambientColor, 0.4);
            scene.add(ambientLight);
            
            // Add hemisphere light with theme colors
            const hemisphereLight = new THREE.HemisphereLight(theme.ambientColor, 0x080820, 0.5);
            scene.add(hemisphereLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1.0, 50);
            pointLight.position.copy(camera.position);
            pointLight.castShadow = true;
            scene.add(pointLight);
            camera.userData.light = pointLight;

            // Initialize dungeon grid
            dungeon = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(1));
            
            // Generate rooms
            const rooms = [];
            const numRooms = 8 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < numRooms; i++) {
                const w = 4 + Math.floor(Math.random() * 4);
                const h = 4 + Math.floor(Math.random() * 4);
                const x = 2 + Math.floor(Math.random() * (MAP_SIZE - w - 4));
                const y = 2 + Math.floor(Math.random() * (MAP_SIZE - h - 4));
                
                let valid = true;
                for (let r of rooms) {
                    if (x < r.x + r.w + 2 && x + w + 2 > r.x && 
                        y < r.y + r.h + 2 && y + h + 2 > r.y) {
                        valid = false;
                        break;
                    }
                }
                
                if (valid) {
                    rooms.push({ x, y, w, h });
                    for (let ry = y; ry < y + h; ry++) {
                        for (let rx = x; rx < x + w; rx++) {
                            dungeon[ry][rx] = 0;
                        }
                    }
                }
            }

            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                const r1 = rooms[i];
                const r2 = rooms[i + 1];
                const cx1 = Math.floor(r1.x + r1.w / 2);
                const cy1 = Math.floor(r1.y + r1.h / 2);
                const cx2 = Math.floor(r2.x + r2.w / 2);
                const cy2 = Math.floor(r2.y + r2.h / 2);

                for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) {
                    dungeon[cy1][x] = 0;
                }
                for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) {
                    dungeon[y][cx2] = 0;
                }
            }

            // Build 3D dungeon with theme colors
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, 4, CELL_SIZE);
            const floorGeometry = new THREE.BoxGeometry(CELL_SIZE, 0.2, CELL_SIZE);
            const ceilingGeometry = new THREE.BoxGeometry(CELL_SIZE, 0.2, CELL_SIZE);
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.wallColor,
                roughness: 0.9,
                metalness: 0.0,
                emissive: theme.wallColor,
                emissiveIntensity: 0.1
            });
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.floorColor,
                roughness: 0.85,
                metalness: 0.0
            });
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.ceilingColor,
                roughness: 0.8,
                metalness: 0.0
            });

            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const posX = (x - MAP_SIZE / 2) * CELL_SIZE;
                    const posZ = (y - MAP_SIZE / 2) * CELL_SIZE;

                    if (dungeon[y][x] === 1) {
                        // Wall
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(posX, 2, posZ);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                    } else {
                        // Floor
                        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                        floor.position.set(posX, 0, posZ);
                        floor.receiveShadow = true;
                        scene.add(floor);
                        
                        // Ceiling
                        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                        ceiling.position.set(posX, 4, posZ);
                        ceiling.receiveShadow = true;
                        scene.add(ceiling);
                    }
                }
            }

            // Position player in first room
            const startRoom = rooms[0];
            const startX = (startRoom.x + startRoom.w / 2 - MAP_SIZE / 2) * CELL_SIZE;
            const startZ = (startRoom.y + startRoom.h / 2 - MAP_SIZE / 2) * CELL_SIZE;
            
            camera.position.set(startX, 2, startZ);
            
            // Position player model at same location
            if (playerModel) {
                playerModel.position.set(startX, 0, startZ);
            }

            // Spawn enemies and pickups
            enemies = [];
            pickups = [];

            let enemyCount = 0;
            const minEnemies = spawnDevilBoss ? 1 : 2;

            for (let i = 1; i < rooms.length; i++) {
                const room = rooms[i];
                
                // Spawn enemy
                if (Math.random() < 0.6 || enemyCount < minEnemies) {
                    let vice;
                    
                    if (spawnDevilBoss && enemyCount === 0) {
                        vice = DEVIL_BOSS;
                    } else {
                        const availableVices = VICES.filter(v => 
                            !DEADLY_SINS.includes(v.name) || !defeatedSins.has(v.name)
                        );
                        if (availableVices.length > 0) {
                            vice = availableVices[Math.floor(Math.random() * availableVices.length)];
                        }
                    }
                    
                    if (vice) {
                        const ex = (room.x + 1 + Math.random() * (room.w - 2) - MAP_SIZE / 2) * CELL_SIZE;
                        const ez = (room.y + 1 + Math.random() * (room.h - 2) - MAP_SIZE / 2) * CELL_SIZE;
                        
                        // Create 3D character model
                        const enemyMesh = createViceModel(vice);
                        enemyMesh.position.set(ex, 0, ez);
                        enemyMesh.castShadow = true;
                        scene.add(enemyMesh);
                        
                        // If this is the Devil and all sins are defeated, add a HUGE beacon
                        if (vice.name === "The Devil") {
                            // Massive glowing red pillar of light reaching to the sky
                            const beaconGeometry = new THREE.CylinderGeometry(2, 2, 50, 32);
                            const beaconMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0.4
                            });
                            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
                            beacon.position.set(ex, 25, ez);
                            scene.add(beacon);
                            
                            // Pulsing red light at Devil's location
                            const devilLight = new THREE.PointLight(0xff0000, 5, 50);
                            devilLight.position.set(ex, 5, ez);
                            scene.add(devilLight);
                            
                            // Spinning warning symbols above
                            for (let i = 0; i < 4; i++) {
                                const warningGeometry = new THREE.BoxGeometry(1, 1, 0.1);
                                const warningMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xffff00,
                                    emissive: 0xffff00,
                                    emissiveIntensity: 1,
                                    metalness: 0.3,
                                    roughness: 0.4
                                });
                                const warning = new THREE.Mesh(warningGeometry, warningMaterial);
                                const angle = (i / 4) * Math.PI * 2;
                                warning.position.set(
                                    ex + Math.cos(angle) * 3,
                                    10 + Math.sin(Date.now() * 0.001 + i) * 2,
                                    ez + Math.sin(angle) * 3
                                );
                                warning.userData.rotate = true;
                                scene.add(warning);
                            }
                            
                            // Add Jesus standing nearby before the Devil fight
                            const jesusBeforeBattle = createJesusModel();
                            jesusBeforeBattle.position.set(ex - 5, 0, ez + 5); // Positioned near the Devil
                            jesusBeforeBattle.rotation.y = Math.atan2(ez - (ez + 5), ex - (ex - 5)); // Face towards Devil
                            scene.add(jesusBeforeBattle);
                        }
                        
                        // Add name label above enemy
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        context.fillStyle = vice.name === "The Devil" ? 'rgba(139, 0, 0, 0.9)' : 'rgba(0, 0, 0, 0.7)';
                        context.fillRect(0, 0, 256, 64);
                        context.font = vice.name === "The Devil" ? 'bold 36px Arial' : 'bold 32px Arial';
                        context.fillStyle = vice.name === "The Devil" ? '#ff0000' : '#e74c3c';
                        context.textAlign = 'center';
                        context.fillText(vice.name.toUpperCase(), 128, 42);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(0, vice.name === "The Devil" ? 4 : 2.5, 0);
                        sprite.scale.set(vice.name === "The Devil" ? 3 : 2, vice.name === "The Devil" ? 0.75 : 0.5, 1);
                        enemyMesh.add(sprite);
                        
                        enemies.push({ 
                            mesh: enemyMesh, 
                            vice: vice,
                            position: { x: ex, z: ez }
                        });
                        enemyCount++;
                    }
                }
                
                // Spawn pickups
                const numPickups = 1 + Math.floor(Math.random() * 3);
                for (let j = 0; j < numPickups; j++) {
                    if (Math.random() < 0.7) {
                        const px = (room.x + 1 + Math.random() * (room.w - 2) - MAP_SIZE / 2) * CELL_SIZE;
                        const pz = (room.y + 1 + Math.random() * (room.h - 2) - MAP_SIZE / 2) * CELL_SIZE;
                        
                        const typeRand = Math.random();
                        let type, pickupMesh;
                        if (typeRand < 0.4) {
                            type = 'holyWater';
                            // Holy water bottle
                            const bottleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.4, 8);
                            const bottleMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x3498db,
                                transparent: true,
                                opacity: 0.7,
                                emissive: 0x3498db,
                                emissiveIntensity: 0.3
                            });
                            pickupMesh = new THREE.Mesh(bottleGeometry, bottleMaterial);
                        } else if (typeRand < 0.7) {
                            type = 'rosary';
                            // 3D Rosary beads
                            const rosaryGroup = new THREE.Group();
                            
                            // Create circular chain of beads
                            const numBeads = 12;
                            const radius = 0.25;
                            const beadGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                            const beadMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x8b4513,
                                metalness: 0.3,
                                roughness: 0.6
                            });
                            
                            for (let i = 0; i < numBeads; i++) {
                                const angle = (i / numBeads) * Math.PI * 2;
                                const bead = new THREE.Mesh(beadGeometry, beadMaterial);
                                bead.position.x = Math.cos(angle) * radius;
                                bead.position.z = Math.sin(angle) * radius;
                                rosaryGroup.add(bead);
                            }
                            
                            // Cross at bottom
                            const crossVertical = new THREE.Mesh(
                                new THREE.BoxGeometry(0.03, 0.3, 0.03),
                                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
                            );
                            crossVertical.position.y = -0.4;
                            rosaryGroup.add(crossVertical);
                            
                            const crossHorizontal = new THREE.Mesh(
                                new THREE.BoxGeometry(0.15, 0.03, 0.03),
                                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
                            );
                            crossHorizontal.position.y = -0.3;
                            rosaryGroup.add(crossHorizontal);
                            
                            // Center bead (larger)
                            const centerBead = new THREE.Mesh(
                                new THREE.SphereGeometry(0.06, 8, 8),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xf39c12,
                                    metalness: 0.5,
                                    roughness: 0.4
                                })
                            );
                            rosaryGroup.add(centerBead);
                            
                            pickupMesh = rosaryGroup;
                        } else {
                            type = 'gold';
                            // Gold coin stack
                            const coinGroup = new THREE.Group();
                            for (let i = 0; i < 3; i++) {
                                const coinGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
                                const coinMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xf39c12,
                                    metalness: 0.8,
                                    roughness: 0.2,
                                    emissive: 0xf39c12,
                                    emissiveIntensity: 0.2
                                });
                                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                                coin.position.y = i * 0.06;
                                coin.rotation.x = Math.PI / 2;
                                coinGroup.add(coin);
                            }
                            pickupMesh = coinGroup;
                        }
                        
                        pickupMesh.position.set(px, 1, pz);
                        scene.add(pickupMesh);
                        
                        pickups.push({ 
                            mesh: pickupMesh, 
                            type: type,
                            position: { x: px, z: pz }
                        });
                    }
                }
            }

            // Add theme-based decorations to rooms
            rooms.forEach((room, index) => {
                if (index > 0) { // Skip first room (player spawn)
                    const decorCount = 2 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < decorCount; i++) {
                        const dx = (room.x + 1 + Math.random() * (room.w - 2) - MAP_SIZE / 2) * CELL_SIZE;
                        const dz = (room.y + 1 + Math.random() * (room.h - 2) - MAP_SIZE / 2) * CELL_SIZE;
                        
                        if (theme.decoration === 'torches') {
                            createTorch(dx, dz, theme.ambientColor);
                        } else {
                            createCrystal(dx, dz, theme.ambientColor);
                        }
                    }
                }
            });

            // Spawn mythical creature for levels 1-7
            if (dungeonLevel >= 1 && dungeonLevel <= 7 && !spawnDevilBoss) {
                const creature = MYTHICAL_CREATURES[dungeonLevel];
                if (creature && rooms.length > 2) {
                    // Spawn in a random room (not first or last)
                    const creatureRoom = rooms[Math.floor(Math.random() * (rooms.length - 2)) + 1];
                    const cx = (creatureRoom.x + Math.floor(creatureRoom.w / 2) - MAP_SIZE / 2) * CELL_SIZE;
                    const cz = (creatureRoom.y + Math.floor(creatureRoom.h / 2) - MAP_SIZE / 2) * CELL_SIZE;
                    
                    const creatureMesh = createMythicalCreatureModel(creature, dungeonLevel);
                    creatureMesh.position.set(cx, 0, cz);
                    creatureMesh.castShadow = true;
                    scene.add(creatureMesh);
                    
                    // Add name label above creature
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    context.fillRect(0, 0, 256, 64);
                    context.font = 'bold 32px Arial';
                    context.fillStyle = '#ffd700';
                    context.textAlign = 'center';
                    context.fillText(creature.name.toUpperCase(), 128, 42);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(0, 2.5, 0);
                    sprite.scale.set(2, 0.5, 1);
                    creatureMesh.add(sprite);
                    
                    enemies.push({ 
                        mesh: creatureMesh, 
                        vice: {
                            name: creature.name,
                            minion: creature.name + " Shade",
                            color: creature.color,
                            catechism: creature.description,
                            verse: creature.verse,
                            reference: creature.reference
                        },
                        position: { x: cx, z: cz },
                        isMythical: true,
                        level: dungeonLevel
                    });
                }
            }

            // Spawn Jeffrey Epstein encounter on Devil level
            if (spawnDevilBoss && rooms.length > 3) {
                const epsteinRoom = rooms[Math.floor(Math.random() * (rooms.length - 3)) + 2];
                const ex = (epsteinRoom.x + Math.floor(epsteinRoom.w / 2) - MAP_SIZE / 2) * CELL_SIZE;
                const ez = (epsteinRoom.y + Math.floor(epsteinRoom.h / 2) - MAP_SIZE / 2) * CELL_SIZE;
                
                const epsteinMesh = createEpsteinModel();
                epsteinMesh.position.set(ex, 0, ez);
                epsteinMesh.castShadow = true;
                scene.add(epsteinMesh);
                
                // Red evil aura around Epstein
                const auraGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32);
                const auraMaterial = new THREE.MeshBasicMaterial({ 
                    color: EPSTEIN_ENCOUNTER.auraColor,
                    transparent: true,
                    opacity: 0.3
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.position.set(ex, 0.05, ez);
                scene.add(aura);
                
                // Red glow
                const epsteinLight = new THREE.PointLight(EPSTEIN_ENCOUNTER.auraColor, 3, 10);
                epsteinLight.position.set(ex, 1, ez);
                scene.add(epsteinLight);
                
                // Name label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'rgba(139, 0, 0, 0.9)';
                context.fillRect(0, 0, 256, 64);
                context.font = 'bold 28px Arial';
                context.fillStyle = '#ff0000';
                context.textAlign = 'center';
                context.fillText(EPSTEIN_ENCOUNTER.name.toUpperCase(), 128, 42);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(0, 2.5, 0);
                sprite.scale.set(2.5, 0.6, 1);
                epsteinMesh.add(sprite);
                
                enemies.push({ 
                    mesh: epsteinMesh, 
                    vice: {
                        name: EPSTEIN_ENCOUNTER.name,
                        minion: EPSTEIN_ENCOUNTER.companion,
                        color: EPSTEIN_ENCOUNTER.color,
                        catechism: EPSTEIN_ENCOUNTER.description,
                        verse: EPSTEIN_ENCOUNTER.verse,
                        reference: EPSTEIN_ENCOUNTER.reference
                    },
                    position: { x: ex, z: ez },
                    isEpstein: true,
                    level: 7
                });
            }

            updateHUD();
        }

        function createTorch(x, z, color) {
            const group = new THREE.Group();
            
            // Torch post
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
            const postMaterial = new THREE.MeshStandardMaterial({ color: 0x3E2723 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 1;
            group.add(post);
            
            // Flame
            const flameGeometry = new THREE.ConeGeometry(0.3, 0.6, 8);
            const flameMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 1
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.y = 2.3;
            group.add(flame);
            
            // Point light for torch
            const light = new THREE.PointLight(color, 1.5, 10);
            light.position.y = 2.3;
            group.add(light);
            
            group.position.set(x, 0, z);
            scene.add(group);
        }

        function createCrystal(x, z, color) {
            const group = new THREE.Group();
            
            // Crystal formation
            const crystalGeometry = new THREE.ConeGeometry(0.3, 1.5, 6);
            const crystalMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                metalness: 0.5,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            
            // Multiple crystal shards
            for (let i = 0; i < 3; i++) {
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                const angle = (i / 3) * Math.PI * 2;
                crystal.position.set(Math.cos(angle) * 0.3, 0.75, Math.sin(angle) * 0.3);
                crystal.rotation.z = Math.PI;
                crystal.rotation.y = angle;
                group.add(crystal);
            }
            
            // Glowing light from crystals
            const light = new THREE.PointLight(color, 2, 8);
            light.position.y = 1;
            group.add(light);
            
            group.position.set(x, 0, z);
            scene.add(group);
        }

        function createMythicalCreatureModel(creature) {
            const group = new THREE.Group();
            
            if (creature.name === "Vampire") {
                // Vampire - humanoid with cape
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                group.add(body);
                
                // Head - pale
                const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xE8D5C9 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.7;
                group.add(head);
                
                // Red eyes
                const eyeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000, 
                    emissive: 0xFF0000,
                    emissiveIntensity: 1
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 1.75, 0.25);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.15, 1.75, 0.25);
                group.add(rightEye);
                
                // Cape
                const capeGeometry = new THREE.ConeGeometry(0.8, 1.5, 8);
                const capeMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                const cape = new THREE.Mesh(capeGeometry, capeMaterial);
                cape.position.set(0, 0.75, -0.3);
                cape.rotation.x = Math.PI;
                group.add(cape);
                
            } else if (creature.name === "Werewolf") {
                // Werewolf - beast-like
                const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                group.add(body);
                
                // Wolf head
                const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.7;
                group.add(head);
                
                // Snout
                const snoutGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.5);
                const snout = new THREE.Mesh(snoutGeometry, bodyMaterial);
                snout.position.set(0, 1.7, 0.5);
                group.add(snout);
                
                // Yellow glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 1.8, 0.4);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 1.8, 0.4);
                group.add(rightEye);
                
                // Claws
                for (let i = 0; i < 2; i++) {
                    const clawGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.5);
                    const clawMaterial = new THREE.MeshStandardMaterial({ color: 0x2F2F2F });
                    const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                    claw.position.set(i === 0 ? -0.5 : 0.5, 0.2, 0.5);
                    group.add(claw);
                }
                
            } else if (creature.name === "Ghost") {
                // Ghost - floating translucent form
                const ghostGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const ghostMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE0E0E0,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.6
                });
                const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial);
                ghost.position.y = 1.5;
                ghost.scale.set(1, 1.5, 1);
                group.add(ghost);
                
                // Wispy tail
                const tailGeometry = new THREE.ConeGeometry(0.5, 1, 8);
                const tail = new THREE.Mesh(tailGeometry, ghostMaterial);
                tail.position.y = 0.5;
                tail.rotation.x = Math.PI;
                group.add(tail);
                
                // Dark hollow eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 1.6, 0.5);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 1.6, 0.5);
                group.add(rightEye);
                
                // Ethereal glow
                const glowLight = new THREE.PointLight(0xE0E0E0, 2, 5);
                glowLight.position.y = 1.5;
                group.add(glowLight);
                
            } else if (creature.name === "Succubus") {
                // Succubus - seductive demon
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFF1493 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFB6C1 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.7;
                group.add(head);
                
                // Horns
                const hornGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                leftHorn.position.set(-0.25, 2.1, 0);
                leftHorn.rotation.z = -Math.PI / 6;
                group.add(leftHorn);
                const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                rightHorn.position.set(0.25, 2.1, 0);
                rightHorn.rotation.z = Math.PI / 6;
                group.add(rightHorn);
                
                // Wings
                const wingGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.05);
                const wingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B0000,
                    transparent: true,
                    opacity: 0.8
                });
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.7, 1.2, -0.2);
                leftWing.rotation.y = Math.PI / 4;
                group.add(leftWing);
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.7, 1.2, -0.2);
                rightWing.rotation.y = -Math.PI / 4;
                group.add(rightWing);
                
            } else if (creature.name === "Sasquatch") {
                // Sasquatch - large hairy beast
                const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4E342E });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                group.add(body);
                
                // Large head
                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.9;
                group.add(head);
                
                // Small eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.95, 0.4);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.95, 0.4);
                group.add(rightEye);
                
                // Long arms
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.15, 1.2, 8);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.6, 0.7, 0);
                leftArm.rotation.z = Math.PI / 6;
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.6, 0.7, 0);
                rightArm.rotation.z = -Math.PI / 6;
                group.add(rightArm);
                
            } else if (creature.name === "Yeti") {
                // Yeti - white furred snow beast
                const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xF0F8FF,
                    emissive: 0xE0FFFF,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.9;
                group.add(head);
                
                // Blue glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00BFFF,
                    emissive: 0x00BFFF,
                    emissiveIntensity: 1
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.95, 0.4);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.95, 0.4);
                group.add(rightEye);
                
                // Large arms
                const armGeometry = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.65, 0.7, 0);
                leftArm.rotation.z = Math.PI / 6;
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.65, 0.7, 0);
                rightArm.rotation.z = -Math.PI / 6;
                group.add(rightArm);
                
                // Icy aura
                const auraLight = new THREE.PointLight(0x87CEEB, 1.5, 5);
                auraLight.position.y = 1;
                group.add(auraLight);
            } else if (creature.name === "Ogre") {
                // Ogre - massive brutal giant
                const bodyGeometry = new THREE.BoxGeometry(1.2, 2, 1);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556B2F,
                    roughness: 0.95
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                group.add(body);
                
                // Large brutish head
                const headGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 2.4;
                group.add(head);
                
                // Tusks
                const tuskGeometry = new THREE.ConeGeometry(0.08, 0.4, 8);
                const tuskMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFACD });
                const leftTusk = new THREE.Mesh(tuskGeometry, tuskMaterial);
                leftTusk.position.set(-0.25, 2.2, 0.45);
                leftTusk.rotation.x = Math.PI;
                group.add(leftTusk);
                const rightTusk = new THREE.Mesh(tuskGeometry, tuskMaterial);
                rightTusk.position.set(0.25, 2.2, 0.45);
                rightTusk.rotation.x = Math.PI;
                group.add(rightTusk);
                
                // Red glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 1
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.3, 2.5, 0.45);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.3, 2.5, 0.45);
                group.add(rightEye);
                
                // Massive arms with clubs
                const armGeometry = new THREE.CylinderGeometry(0.3, 0.25, 1.5, 8);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.75, 1, 0);
                leftArm.rotation.z = Math.PI / 4;
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.75, 1, 0);
                rightArm.rotation.z = -Math.PI / 4;
                group.add(rightArm);
                
                // Wooden club in right hand
                const clubGeometry = new THREE.CylinderGeometry(0.15, 0.25, 1, 8);
                const clubMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const club = new THREE.Mesh(clubGeometry, clubMaterial);
                club.position.set(1.2, 0.3, 0);
                club.rotation.z = -Math.PI / 3;
                group.add(club);
            }
            
            return group;
        }

        function createEpsteinModel() {
            const group = new THREE.Group();
            
            // Human figure - business suit
            const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.4);
            const suitMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,  // Black suit
                roughness: 0.7,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, suitMaterial);
            body.position.y = 0.8;
            group.add(body);
            
            // Head - pale complexion
            const headGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.4);
            const skinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE8D5C9,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 1.65;
            group.add(head);
            
            // Dark eyes
            const eyeGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.12, 1.7, 0.2);
            group.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 1.7, 0.2);
            group.add(rightEye);
            
            // Sinister smile (red line)
            const smileGeometry = new THREE.BoxGeometry(0.25, 0.03, 0.03);
            const smileMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            });
            const smile = new THREE.Mesh(smileGeometry, smileMaterial);
            smile.position.set(0, 1.5, 0.2);
            group.add(smile);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.12, 0.12, 1, 8);
            const leftArm = new THREE.Mesh(armGeometry, suitMaterial);
            leftArm.position.set(-0.4, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, suitMaterial);
            rightArm.position.set(0.4, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.1, 0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.1, 0);
            group.add(rightLeg);
            
            // Evil red aura around him
            const auraGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.position.y = 1;
            group.add(aura);
            
            return group;
        }

        function updateHUD() {
            document.getElementById('level').textContent = dungeonLevel;
            document.getElementById('sins').textContent = defeatedSins.size;
            document.getElementById('virtues').textContent = inventory.virtueItems.length;
            document.getElementById('water').textContent = inventory.holyWater;
            document.getElementById('rosary').textContent = inventory.rosaries;
            document.getElementById('elixirs').textContent = inventory.divineElixirs;
            document.getElementById('gold').textContent = inventory.gold;
        }

        function levelUpHeroes() {
            // Each level-up gives permanent stat increases to all heroes
            // Stats scale with dungeon level for more dramatic progression
            const levelMultiplier = 1 + (dungeonLevel - 1) * 0.2; // 1x at level 1, 1.2x at 2, 1.4x at 3, etc.
            
            const hpIncrease = Math.floor(15 * levelMultiplier);
            const mpIncrease = Math.floor(5 * levelMultiplier);
            const atkIncrease = Math.floor(3 * levelMultiplier);
            const defIncrease = Math.floor(2 * levelMultiplier);
            
            heroes.forEach(hero => {
                hero.maxHp += hpIncrease;
                hero.hp += hpIncrease; // Also heal them
                hero.maxMp += mpIncrease;
                hero.mp += mpIncrease; // Also restore MP
                hero.atk += atkIncrease;
                hero.def += defIncrease;
            });
            
            return `All Heroes: +${hpIncrease} Max HP, +${mpIncrease} Max MP, +${atkIncrease} ATK, +${defIncrease} DEF`;
        }

        function showMessage(text, duration = 3000) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = text;
            msgEl.style.display = 'block';
            setTimeout(() => {
                msgEl.style.display = 'none';
            }, duration);
        }

        function startBattle(enemy) {
            gameState = 'battle';
            battle.active = true;
            
            // Hide mobile interact button during battle
            if (isMobile) {
                const interactBtn = document.getElementById('mobile-interact-btn');
                if (interactBtn) interactBtn.style.display = 'none';
            }
            
            const isFinalBoss = enemy.vice.name === "The Devil";
            
            if (isFinalBoss && inventory.virtueItems.length === 7) {
                showOneRingVictory();
                return;
            }
            
            // Setup heroes
            heroes.forEach(hero => {
                hero.hp = hero.maxHp + inventory.hpBoost;
                hero.mp = hero.maxMp;
                // Don't adjust divine party stats - they're already powerful
                if (!newGamePlus) {
                    hero.atk = (hero.name === "St. Vincent" ? 15 : hero.name === "St. Michael" ? 18 : 14) + inventory.atkBoost;
                    hero.def = (hero.name === "St. Vincent" ? 8 : hero.name === "St. Michael" ? 6 : 10) + inventory.defBoost;
                }
            });
            
            // Setup enemies
            let viceHp, minionHp, viceAtk, minionAtk;
            
            // Check if this is Jeffrey Epstein
            if (enemy.isEpstein) {
                const levelMultiplier = 1 + (dungeonLevel - 1) * 0.5;
                viceHp = Math.floor(EPSTEIN_ENCOUNTER.baseHp * levelMultiplier);
                minionHp = Math.floor(EPSTEIN_ENCOUNTER.companionHp * levelMultiplier);
                viceAtk = Math.floor(EPSTEIN_ENCOUNTER.baseAtk * levelMultiplier);
                minionAtk = Math.floor(EPSTEIN_ENCOUNTER.companionAtk * levelMultiplier);
            }
            // Check if this is a mythical creature
            else if (enemy.isMythical) {
                const creature = MYTHICAL_CREATURES[enemy.level || dungeonLevel];
                // Scale mythical creature stats based on dungeon level (they get stronger as you progress)
                const levelMultiplier = 1 + (dungeonLevel - 1) * 0.5; // 1x at level 1, 1.5x at level 2, 2x at level 3, etc.
                viceHp = Math.floor(creature.baseHp * levelMultiplier);
                minionHp = Math.floor(creature.baseHp * 0.6 * levelMultiplier);
                viceAtk = Math.floor(creature.baseAtk * levelMultiplier);
                minionAtk = Math.floor(creature.baseAtk * 0.7 * levelMultiplier);
            } else if (isFinalBoss) {
                // Devil scales massively with defeated sins
                const sinMultiplier = 1 + (defeatedSins.size * 0.3); // Gets stronger with each sin defeated
                viceHp = Math.floor(200 * sinMultiplier);
                minionHp = Math.floor(100 * sinMultiplier);
                viceAtk = Math.floor(30 * sinMultiplier);
                minionAtk = Math.floor(20 * sinMultiplier);
            } else {
                // Deadly Sins scale aggressively with level (exponential growth)
                const baseHp = 50;
                const baseAtk = 15;
                const levelMultiplier = Math.pow(1.4, dungeonLevel - 1); // 1x, 1.4x, 1.96x, 2.74x, 3.84x, 5.38x, 7.53x
                
                viceHp = Math.floor(baseHp * levelMultiplier);
                minionHp = Math.floor(30 * levelMultiplier);
                viceAtk = Math.floor(baseAtk * levelMultiplier);
                minionAtk = Math.floor(10 * levelMultiplier);
            }
            
            // New Game+ mode: Enemies are 200x stronger!
            if (newGamePlus) {
                viceHp *= 200;
                minionHp *= 200;
                viceAtk *= 200;
                minionAtk *= 200;
            }
            
            battle.enemies = [
                { name: enemy.vice.name, hp: viceHp, maxHp: viceHp, atk: viceAtk, def: 4, vice: enemy.vice },
                { name: enemy.vice.minion, hp: minionHp, maxHp: minionHp, atk: minionAtk, def: 2, vice: enemy.vice }
            ];
            
            battle.currentHeroIndex = 0;
            battle.targetIndex = 0;
            battle.phase = 'menu';
            battle.log = [`Facing ${enemy.vice.name}!`];
            
            // Create 3D battle scene
            createBattleScene(enemy.vice, enemy.isEpstein);
            
            updateBattleUI();
            document.getElementById('battle-ui').style.display = 'block';
            document.getElementById('battle-status').style.display = 'block';
            document.getElementById('enemy-status').style.display = 'block';
            document.exitPointerLock();
        }

        let battleScene = null;
        let battleCamera = null;
        let battleHeroModels = [];
        let battleEnemyModels = [];

        function createBattleScene(vice, isEpstein = false) {
            // Clear any existing battle scene
            if (battleScene) {
                while(battleScene.children.length > 0) { 
                    const obj = battleScene.children[0];
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                    battleScene.remove(obj);
                }
            }
            
            battleScene = new THREE.Scene();
            
            // Special island scene for Epstein
            if (isEpstein) {
                // Sky - bright blue
                battleScene.background = new THREE.Color(0x87CEEB);
                
                // Ocean floor
                const oceanGeometry = new THREE.PlaneGeometry(50, 50);
                const oceanMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1E90FF,
                    roughness: 0.3,
                    metalness: 0.5
                });
                const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
                ocean.rotation.x = -Math.PI / 2;
                ocean.position.y = -0.5;
                ocean.receiveShadow = true;
                battleScene.add(ocean);
                
                // Island - sandy ground
                const islandGeometry = new THREE.CircleGeometry(12, 32);
                const sandMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xF4E4C1,
                    roughness: 0.95
                });
                const island = new THREE.Mesh(islandGeometry, sandMaterial);
                island.rotation.x = -Math.PI / 2;
                island.receiveShadow = true;
                battleScene.add(island);
                
                // Blue and white building in background (like Little St. James temple)
                const buildingGroup = new THREE.Group();
                
                // Main structure - blue and white striped dome
                const domeGeometry = new THREE.SphereGeometry(2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const domeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4169E1,
                    emissive: 0x1E3A8A,
                    emissiveIntensity: 0.2
                });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = 3;
                buildingGroup.add(dome);
                
                // White base
                const baseGeometry = new THREE.CylinderGeometry(2.2, 2.5, 2, 8);
                const whiteMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFAFA,
                    roughness: 0.4
                });
                const base = new THREE.Mesh(baseGeometry, whiteMaterial);
                base.position.y = 1;
                buildingGroup.add(base);
                
                // White columns
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const columnGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
                    const column = new THREE.Mesh(columnGeometry, whiteMaterial);
                    column.position.set(
                        Math.cos(angle) * 2.3,
                        1.25,
                        Math.sin(angle) * 2.3
                    );
                    buildingGroup.add(column);
                }
                
                // Gold top ornament
                const ornamentGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const goldMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.3
                });
                const ornament = new THREE.Mesh(ornamentGeometry, goldMaterial);
                ornament.position.y = 5;
                buildingGroup.add(ornament);
                
                buildingGroup.position.set(0, 0, -10);
                buildingGroup.castShadow = true;
                battleScene.add(buildingGroup);
                
                // Palm trees on island
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const palmGroup = new THREE.Group();
                    
                    // Trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.25, 3, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 1.5;
                    palmGroup.add(trunk);
                    
                    // Leaves
                    for (let j = 0; j < 6; j++) {
                        const leafAngle = (j / 6) * Math.PI * 2;
                        const leafGeometry = new THREE.BoxGeometry(0.3, 2, 0.1);
                        const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                        leaf.position.set(
                            Math.cos(leafAngle) * 0.5,
                            3.5,
                            Math.sin(leafAngle) * 0.5
                        );
                        leaf.rotation.z = Math.cos(leafAngle) * Math.PI / 4;
                        leaf.rotation.x = Math.sin(leafAngle) * Math.PI / 4;
                        palmGroup.add(leaf);
                    }
                    
                    palmGroup.position.set(
                        Math.cos(angle) * 8,
                        0,
                        Math.sin(angle) * 8
                    );
                    palmGroup.castShadow = true;
                    battleScene.add(palmGroup);
                }
                
            } else {
                // Normal battle background
                // Battle background color (grass/desert/dungeon based on level)
                const bgColors = [0x87CEEB, 0xFFE4B5, 0x4a4a6a];
                const bgIndex = Math.min(Math.floor((dungeonLevel - 1) / 3), 2);
                battleScene.background = new THREE.Color(bgColors[bgIndex]);
                
                // Ground plane
                const groundColors = [0x5D8C3E, 0xE6C89E, 0x3a3a4e];
                const groundGeometry = new THREE.PlaneGeometry(20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: groundColors[bgIndex] });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                battleScene.add(ground);
                
                // Add some environment elements (rocks/trees)
                for (let i = 0; i < 5; i++) {
                    const envGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 6);
                    const envMat = new THREE.MeshStandardMaterial({ 
                        color: bgIndex === 0 ? 0x2d5016 : bgIndex === 1 ? 0x8B7355 : 0x4a4a5a
                    });
                    const env = new THREE.Mesh(envGeo, envMat);
                    env.position.set(
                        -8 + Math.random() * 16,
                        0.75,
                        -8 + Math.random() * 16
                    );
                    env.receiveShadow = true;
                    env.castShadow = true;
                    battleScene.add(env);
                }
            }
            
            // Lighting for battle
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            battleScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            battleScene.add(directionalLight);
            
            // Add rim light for dramatic effect (FF7 style)
            const rimLight = new THREE.DirectionalLight(0x6699ff, 0.3);
            rimLight.position.set(-5, 5, -5);
            battleScene.add(rimLight);
            
            // Position heroes on the left side
            battleHeroModels = [];
            let heroModels;
            
            if (newGamePlus) {
                // Divine party models
                heroModels = [
                    createJesusModel(),
                    createPadrePioModel(),
                    createStVincentFerrerModel(),
                    createMotherMaryModel()
                ];
            } else {
                // Regular party models
                heroModels = [
                    createStVincentModel(),
                    createStMichaelModel(),
                    createStJoanModel()
                ];
            }
            
            for (let i = 0; i < heroModels.length; i++) {
                const heroModel = heroModels[i];
                heroModel.position.set(-5, 0, -3 + i * 2);
                heroModel.rotation.y = Math.PI / 6; // Face right slightly
                heroModel.castShadow = true;
                battleScene.add(heroModel);
                battleHeroModels.push(heroModel);
            }
            
            // Position enemies on the right side
            battleEnemyModels = [];
            for (let i = 0; i < 2; i++) {
                let enemyModel;
                // Check if this is Epstein
                if (isEpstein && vice.name === EPSTEIN_ENCOUNTER.name) {
                    if (i === 0) {
                        enemyModel = createEpsteinModel();
                    } else {
                        // Ghislaine - similar but female
                        enemyModel = createEpsteinModel(); // Reuse model, will scale/modify
                        enemyModel.scale.set(0.85, 0.85, 0.85); // Smaller for Ghislaine
                    }
                }
                // Check if this is a mythical creature
                else {
                    const creatureData = MYTHICAL_CREATURES[dungeonLevel];
                    if (creatureData && vice.name === creatureData.name) {
                        enemyModel = createMythicalCreatureModel(creatureData, dungeonLevel);
                    } else {
                        enemyModel = createViceModel(vice);
                    }
                }
                
                enemyModel.position.set(5, 0, -1 + i * 2);
                enemyModel.rotation.y = -Math.PI / 6; // Face left slightly
                enemyModel.castShadow = true;
                
                // Scale down minion slightly (if not already scaled for Ghislaine)
                if (i === 1 && !isEpstein) {
                    enemyModel.scale.set(0.7, 0.7, 0.7);
                }
                
                battleScene.add(enemyModel);
                battleEnemyModels.push(enemyModel);
            }
            
            // Battle camera setup with dynamic positioning
            battleCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            battleCamera.position.set(0, 4, 10);
            battleCamera.lookAt(0, 1, 0);
            
            // Store original camera position for animations
            battleCamera.userData.originalPosition = battleCamera.position.clone();
            battleCamera.userData.targetPosition = battleCamera.position.clone();
        }

        // Animate battle camera (called during battles)
        function updateBattleCamera() {
            if (!battleCamera) return;
            
            // Smooth camera movement
            if (battleCamera.userData.targetPosition) {
                battleCamera.position.lerp(battleCamera.userData.targetPosition, 0.1);
            }
            
            // Subtle camera sway
            const time = Date.now() * 0.0005;
            const swayAmount = 0.1;
            battleCamera.position.x += Math.sin(time) * swayAmount * 0.05;
            battleCamera.position.y += Math.cos(time * 0.7) * swayAmount * 0.05;
            
            battleCamera.lookAt(0, 1, 0);
        }

        // Focus camera on hero during their turn
        function focusCameraOnHero(index) {
            if (!battleCamera || !battleHeroModels[index]) return;
            const hero = battleHeroModels[index];
            battleCamera.userData.targetPosition = new THREE.Vector3(
                hero.position.x + 2,
                3,
                hero.position.z + 6
            );
        }

        // Focus camera on enemy during attack
        function focusCameraOnEnemy(index) {
            if (!battleCamera || !battleEnemyModels[index]) return;
            const enemy = battleEnemyModels[index];
            battleCamera.userData.targetPosition = new THREE.Vector3(
                enemy.position.x - 2,
                3,
                enemy.position.z + 6
            );
        }

        // Reset camera to default battle view
        function resetBattleCamera() {
            if (!battleCamera) return;
            battleCamera.userData.targetPosition = new THREE.Vector3(0, 4, 10);
        }

        function disposeBattleScene() {
            if (battleScene) {
                while(battleScene.children.length > 0) { 
                    const obj = battleScene.children[0];
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(m => m.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                    battleScene.remove(obj);
                }
                battleScene = null;
            }
            battleHeroModels = [];
            battleEnemyModels = [];
        }

        function updateBattleUI() {
            // Highlight active hero
            battleHeroModels.forEach((model, i) => {
                if (i === battle.currentHeroIndex && battle.phase !== 'enemyTurn') {
                    model.position.y = Math.sin(Date.now() * 0.003) * 0.1; // Gentle bounce
                } else {
                    model.position.y = 0;
                }
            });
            
            // Highlight targeted enemy
            battleEnemyModels.forEach((model, i) => {
                if (i === battle.targetIndex && battle.phase === 'target') {
                    model.position.y = Math.sin(Date.now() * 0.005) * 0.1;
                } else {
                    model.position.y = 0;
                }
            });
            
            // Update hero status display (bottom right - FF style)
            const heroStatusEl = document.getElementById('battle-status');
            heroStatusEl.innerHTML = '';
            heroStatusEl.style.display = 'block';
            
            heroes.forEach((hero, i) => {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'hero-status' + (i === battle.currentHeroIndex && battle.phase !== 'enemyTurn' ? ' active' : '');
                const hpPercent = Math.max(0, (hero.hp / (hero.maxHp + inventory.hpBoost)) * 100);
                const mpPercent = Math.max(0, (hero.mp / hero.maxMp) * 100);
                statusDiv.innerHTML = `
                    <div class="hero-name">${hero.name}</div>
                    <div class="hero-stats">
                        <div class="stat-bar-container hp-bar">
                            <span class="stat-label">HP</span>
                            <div class="stat-bar">
                                <div class="stat-bar-fill" style="width: ${hpPercent}%;"></div>
                            </div>
                            <span class="stat-value">${Math.max(0, hero.hp)}/${hero.maxHp + inventory.hpBoost}</span>
                        </div>
                        <div class="stat-bar-container mp-bar">
                            <span class="stat-label">MP</span>
                            <div class="stat-bar">
                                <div class="stat-bar-fill" style="width: ${mpPercent}%;"></div>
                            </div>
                            <span class="stat-value">${hero.mp}/${hero.maxMp}</span>
                        </div>
                    </div>
                `;
                heroStatusEl.appendChild(statusDiv);
            });
            
            // Enemy status hidden in FFX style - no enemy health bars shown
            
            // Update actions menu (bottom left - FFX style)
            const actionsEl = document.getElementById('battle-actions');
            if (battle.phase === 'menu') {
                const hero = heroes[battle.currentHeroIndex];
                actionsEl.innerHTML = `
                    <button class="battle-btn selected" onclick="selectBattleAction('attack')">Attack</button>
                    <button class="battle-btn" onclick="selectBattleAction('special')">${hero.specialAttack} (${hero.specialCost} MP)</button>
                    <button class="battle-btn" onclick="selectBattleAction('prayer')">Call Saints (10 MP)</button>
                    <button class="battle-btn" onclick="selectBattleAction('item')">Item</button>
                    <button class="battle-btn" onclick="selectBattleAction('flee')">Flee</button>
                `;
            } else if (battle.phase === 'target') {
                const targetEnemy = battle.enemies[battle.targetIndex];
                const enemyName = targetEnemy ? targetEnemy.name : 'Enemy';
                actionsEl.innerHTML = `
                    <div style="padding: 6px; background: rgba(231, 76, 60, 0.2); border: 1px solid rgba(231, 76, 60, 0.4); border-radius: 3px; margin-bottom: 4px; text-align: center;">
                        <div style="font-weight: bold; color: #e74c3c; text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);">TARGET:</div>
                        <div style="font-weight: bold; color: #ecf0f1; text-shadow: 2px 2px 4px rgba(0, 0, 0, 1); font-size: clamp(10px, 1.5vw, 12px);">${enemyName}</div>
                    </div>
                    <button class="battle-btn" onclick="changeTarget(-1)">◀ Prev</button>
                    <button class="battle-btn selected" onclick="confirmTarget()">Confirm</button>
                    <button class="battle-btn" onclick="changeTarget(1)">Next ▶</button>
                    <button class="battle-btn" onclick="cancelTarget()">Back</button>
                `;
            } else if (battle.phase === 'item') {
                actionsEl.innerHTML = `
                    <button class="battle-btn" onclick="useItem('holyWater')">Holy Water (${inventory.holyWater})</button>
                    <button class="battle-btn" onclick="useItem('rosary')">Rosary (${inventory.rosaries})</button>
                    <button class="battle-btn" onclick="useItem('divineElixir')">Divine Elixir (${inventory.divineElixirs})</button>
                    <button class="battle-btn selected" onclick="battle.phase='menu'; updateBattleUI();">Back</button>
                `;
            }
            
            // Battle log hidden in FFX style - no update needed
        }

        function selectBattleAction(action) {
            if (action === 'attack' || action === 'special') {
                battle.currentAction = action;
                battle.phase = 'target';
                battle.targetIndex = battle.enemies.findIndex(e => e.hp > 0);
                focusCameraOnEnemy(battle.targetIndex);
                updateBattleUI();
            } else if (action === 'prayer') {
                // Prayer targets all enemies (Call upon the Saints)
                battle.currentAction = 'prayer';
                battle.phase = 'executing';
                executePrayerAttack();
            } else if (action === 'item') {
                battle.phase = 'item';
                updateBattleUI();
            } else if (action === 'flee') {
                if (Math.random() < 0.6) {
                    battle.log.push('Fled successfully!');
                    endBattle(false, true);
                } else {
                    battle.log.push("Couldn't escape!");
                    nextTurn();
                }
            }
        }

        function executePrayerAttack() {
            const hero = heroes[battle.currentHeroIndex];
            
            if (hero.mp >= 10) {
                const damage = 20 + Math.floor(Math.random() * 10);
                let enemiesHit = 0;
                
                battle.enemies.forEach((enemy, i) => {
                    if (enemy.hp > 0) {
                        enemy.hp -= damage;
                        enemiesHit++;
                        
                        // Shake enemy
                        if (battleEnemyModels[i]) {
                            const enemyModel = battleEnemyModels[i];
                            let shakeCount = 0;
                            const shakeInterval = setInterval(() => {
                                enemyModel.position.x += (Math.random() - 0.5) * 0.3;
                                shakeCount++;
                                if (shakeCount > 5) {
                                    clearInterval(shakeInterval);
                                    enemyModel.position.x = 5;
                                }
                            }, 50);
                        }
                        
                        // Fade out if defeated
                        if (enemy.hp <= 0 && battleEnemyModels[i]) {
                            const enemyModel = battleEnemyModels[i];
                            let opacity = 1;
                            const fadeInterval = setInterval(() => {
                                opacity -= 0.1;
                                enemyModel.traverse((child) => {
                                    if (child.material) {
                                        child.material.opacity = opacity;
                                        child.material.transparent = true;
                                    }
                                });
                                if (opacity <= 0) {
                                    clearInterval(fadeInterval);
                                }
                            }, 50);
                        }
                    }
                });
                
                hero.mp -= 10;
                battle.log.push(`${hero.name} calls upon the Saints! ${damage} holy damage to all foes!`);
                
                // All heroes glow
                battleHeroModels.forEach(heroModel => {
                    heroModel.traverse((child) => {
                        if (child.material) {
                            const originalEmissive = child.material.emissive ? child.material.emissive.clone() : new THREE.Color(0x000000);
                            child.material.emissive = new THREE.Color(0xffffff);
                            child.material.emissiveIntensity = 0.8;
                            setTimeout(() => {
                                child.material.emissive = originalEmissive;
                                child.material.emissiveIntensity = 0;
                            }, 1000);
                        }
                    });
                });
                
            } else {
                battle.log.push(`${hero.name} lacks MP!`);
            }
            
            setTimeout(() => {
                nextTurn();
            }, 1200);
        }

        function changeTarget(delta) {
            let newIndex = battle.targetIndex + delta;
            while (newIndex >= 0 && newIndex < battle.enemies.length && battle.enemies[newIndex].hp <= 0) {
                newIndex += delta;
            }
            if (newIndex >= 0 && newIndex < battle.enemies.length) {
                battle.targetIndex = newIndex;
                focusCameraOnEnemy(battle.targetIndex);
                updateBattleUI();
            }
        }

        function confirmTarget() {
            const hero = heroes[battle.currentHeroIndex];
            const target = battle.enemies[battle.targetIndex];
            
            if (battle.currentAction === 'attack') {
                const damage = Math.max(1, hero.atk - target.def + Math.floor(Math.random() * 5));
                target.hp -= damage;
                battle.log.push(`${hero.name} deals ${damage} damage to ${target.name}!`);
                
                // Attack animation - hero moves forward
                if (battleHeroModels[battle.currentHeroIndex]) {
                    const heroModel = battleHeroModels[battle.currentHeroIndex];
                    const originalZ = heroModel.position.z;
                    
                    // Quick dash forward
                    let dashProgress = 0;
                    const dashInterval = setInterval(() => {
                        dashProgress += 0.2;
                        heroModel.position.z = originalZ + Math.sin(dashProgress * Math.PI) * 3;
                        
                        if (dashProgress >= 1) {
                            clearInterval(dashInterval);
                            heroModel.position.z = originalZ;
                        }
                    }, 30);
                }
                
                // Damage animation - enemy shakes and flashes red
                if (battleEnemyModels[battle.targetIndex] && target.hp > 0) {
                    const enemyModel = battleEnemyModels[battle.targetIndex];
                    let shakeCount = 0;
                    const originalX = enemyModel.position.x;
                    
                    const damageInterval = setInterval(() => {
                        enemyModel.position.x = originalX + (Math.random() - 0.5) * 0.4;
                        
                        // Flash red
                        enemyModel.traverse((child) => {
                            if (child.material) {
                                child.material.emissive = new THREE.Color(0xff0000);
                                child.material.emissiveIntensity = 0.5;
                            }
                        });
                        
                        shakeCount++;
                        if (shakeCount > 6) {
                            clearInterval(damageInterval);
                            enemyModel.position.x = originalX;
                            
                            // Reset color
                            enemyModel.traverse((child) => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(0x000000);
                                    child.material.emissiveIntensity = 0;
                                }
                            });
                        }
                    }, 50);
                }
                
                // Enemy defeated - fade out
                if (target.hp <= 0 && battleEnemyModels[battle.targetIndex]) {
                    setTimeout(() => {
                        const enemyModel = battleEnemyModels[battle.targetIndex];
                        let opacity = 1;
                        const fadeInterval = setInterval(() => {
                            opacity -= 0.1;
                            enemyModel.traverse((child) => {
                                if (child.material) {
                                    child.material.opacity = opacity;
                                    child.material.transparent = true;
                                }
                            });
                            if (opacity <= 0) {
                                clearInterval(fadeInterval);
                            }
                        }, 50);
                    }, 400);
                }
                
            } else if (battle.currentAction === 'special') {
                const specialCost = hero.specialCost;
                const specialDamage = hero.specialDamage;
                
                if (hero.mp >= specialCost) {
                    target.hp -= specialDamage;
                    hero.mp -= specialCost;
                    battle.log.push(`${hero.name} uses ${hero.specialAttack}! ${specialDamage} damage!`);
                    
                    // SPECIAL ATTACK ANIMATIONS
                    if (hero.name === "St. Michael") {
                        // Heavenly Host - Angels descend from heaven
                        if (battleHeroModels[battle.currentHeroIndex]) {
                            const heroModel = battleHeroModels[battle.currentHeroIndex];
                            
                            // Hero glows with divine light
                            heroModel.traverse((child) => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(0xffd700);
                                    child.material.emissiveIntensity = 1.0;
                                }
                            });
                            
                            // Create descending angel lights
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    const angelLight = new THREE.Mesh(
                                        new THREE.SphereGeometry(0.3, 8, 8),
                                        new THREE.MeshBasicMaterial({ 
                                            color: 0xffffff,
                                            transparent: true,
                                            opacity: 1
                                        })
                                    );
                                    angelLight.position.set(
                                        battleEnemyModels[battle.targetIndex].position.x + (Math.random() - 0.5) * 2,
                                        10,
                                        battleEnemyModels[battle.targetIndex].position.z + (Math.random() - 0.5) * 2
                                    );
                                    battleScene.add(angelLight);
                                    
                                    // Descend
                                    let descent = 0;
                                    const descendInterval = setInterval(() => {
                                        descent += 0.5;
                                        angelLight.position.y = 10 - descent;
                                        
                                        if (angelLight.position.y <= 0) {
                                            clearInterval(descendInterval);
                                            battleScene.remove(angelLight);
                                        }
                                    }, 30);
                                }, i * 100);
                            }
                            
                            setTimeout(() => {
                                heroModel.traverse((child) => {
                                    if (child.material) {
                                        child.material.emissive = new THREE.Color(0x000000);
                                        child.material.emissiveIntensity = 0;
                                    }
                                });
                            }, 1500);
                        }
                        
                    } else if (hero.name === "St. Vincent") {
                        // Rosary Throw
                        if (battleHeroModels[battle.currentHeroIndex]) {
                            const heroModel = battleHeroModels[battle.currentHeroIndex];
                            
                            // Create rosary projectile
                            const rosary = new THREE.Group();
                            const beadGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                            const beadMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                            for (let i = 0; i < 5; i++) {
                                const bead = new THREE.Mesh(beadGeometry, beadMaterial);
                                bead.position.x = i * 0.15;
                                rosary.add(bead);
                            }
                            
                            rosary.position.copy(heroModel.position);
                            rosary.position.y = 1.5;
                            battleScene.add(rosary);
                            
                            // Throw animation
                            const targetPos = battleEnemyModels[battle.targetIndex].position;
                            let throwProgress = 0;
                            const throwInterval = setInterval(() => {
                                throwProgress += 0.05;
                                
                                rosary.position.x = heroModel.position.x + (targetPos.x - heroModel.position.x) * throwProgress;
                                rosary.position.z = heroModel.position.z + (targetPos.z - heroModel.position.z) * throwProgress;
                                rosary.position.y = 1.5 + Math.sin(throwProgress * Math.PI) * 2;
                                rosary.rotation.z += 0.3;
                                
                                if (throwProgress >= 1) {
                                    clearInterval(throwInterval);
                                    battleScene.remove(rosary);
                                }
                            }, 30);
                        }
                        
                    } else if (hero.name === "St. Joan") {
                        // Divine Charge - Prayer then sword lunge
                        if (battleHeroModels[battle.currentHeroIndex]) {
                            const heroModel = battleHeroModels[battle.currentHeroIndex];
                            const originalZ = heroModel.position.z;
                            
                            // Prayer pose - glow
                            heroModel.traverse((child) => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(0xffd700);
                                    child.material.emissiveIntensity = 0.8;
                                }
                            });
                            
                            // After prayer, charge forward
                            setTimeout(() => {
                                let chargeProgress = 0;
                                const chargeInterval = setInterval(() => {
                                    chargeProgress += 0.1;
                                    heroModel.position.z = originalZ + Math.sin(chargeProgress * Math.PI) * 5;
                                    
                                    if (chargeProgress >= 1) {
                                        clearInterval(chargeInterval);
                                        heroModel.position.z = originalZ;
                                        
                                        // Stop glowing
                                        heroModel.traverse((child) => {
                                            if (child.material) {
                                                child.material.emissive = new THREE.Color(0x000000);
                                                child.material.emissiveIntensity = 0;
                                            }
                                        });
                                    }
                                }, 30);
                            }, 800);
                        }
                    }
                    
                    // Enemy damage animation
                    if (battleEnemyModels[battle.targetIndex] && target.hp > 0) {
                        setTimeout(() => {
                            const enemyModel = battleEnemyModels[battle.targetIndex];
                            let shakeCount = 0;
                            const originalX = enemyModel.position.x;
                            
                            const damageInterval = setInterval(() => {
                                enemyModel.position.x = originalX + (Math.random() - 0.5) * 0.5;
                                shakeCount++;
                                if (shakeCount > 8) {
                                    clearInterval(damageInterval);
                                    enemyModel.position.x = originalX;
                                }
                            }, 50);
                        }, 600);
                    }
                    
                    if (target.hp <= 0 && battleEnemyModels[battle.targetIndex]) {
                        setTimeout(() => {
                            const enemyModel = battleEnemyModels[battle.targetIndex];
                            let opacity = 1;
                            const fadeInterval = setInterval(() => {
                                opacity -= 0.1;
                                enemyModel.traverse((child) => {
                                    if (child.material) {
                                        child.material.opacity = opacity;
                                        child.material.transparent = true;
                                    }
                                });
                                if (opacity <= 0) {
                                    clearInterval(fadeInterval);
                                }
                            }, 50);
                        }, 800);
                    }
                } else {
                    battle.log.push(`${hero.name} lacks MP!`);
                }
            }
            
            setTimeout(() => {
                nextTurn();
            }, battle.currentAction === 'special' ? 2000 : 800);
        }

        function cancelTarget() {
            battle.phase = 'menu';
            updateBattleUI();
        }

        function useItem(itemType) {
            const hero = heroes[battle.currentHeroIndex];
            
            if (itemType === 'holyWater' && inventory.holyWater > 0) {
                hero.hp = Math.min(hero.maxHp + inventory.hpBoost, hero.hp + 50);
                inventory.holyWater--;
                battle.log.push(`${hero.name} drinks Holy Water! +50 HP`);
                updateHUD();
                nextTurn();
            } else if (itemType === 'rosary' && inventory.rosaries > 0) {
                const damage = 30 + dungeonLevel * 5;
                battle.enemies.forEach(enemy => {
                    if (enemy.hp > 0) enemy.hp -= damage;
                });
                inventory.rosaries--;
                battle.log.push(`${hero.name} prays! Divine light strikes all foes!`);
                updateHUD();
                nextTurn();
            } else if (itemType === 'divineElixir' && inventory.divineElixirs > 0) {
                // Restore full HP and MP to entire party
                heroes.forEach(h => {
                    h.hp = h.maxHp + inventory.hpBoost;
                    h.mp = h.maxMp;
                });
                inventory.divineElixirs--;
                battle.log.push(`${hero.name} uses Divine Elixir! All heroes fully restored!`);
                updateHUD();
                nextTurn();
            } else {
                battle.log.push('No items!');
                updateBattleUI();
            }
        }

        function nextTurn() {
            if (checkBattleEnd()) return;
            
            battle.currentHeroIndex++;
            if (battle.currentHeroIndex >= heroes.length) {
                executeEnemyTurn();
            } else {
                battle.phase = 'menu';
                battle.targetIndex = battle.enemies.findIndex(e => e.hp > 0);
                battle.log.push(`${heroes[battle.currentHeroIndex].name}'s turn!`);
                resetBattleCamera();
                focusCameraOnHero(battle.currentHeroIndex);
                updateBattleUI();
            }
        }

        function executeEnemyTurn() {
            let aliveEnemies = battle.enemies.filter(e => e.hp > 0);
            
            aliveEnemies.forEach(enemy => {
                const aliveHeroes = heroes.filter(h => h.hp > 0);
                if (aliveHeroes.length > 0) {
                    const target = aliveHeroes[Math.floor(Math.random() * aliveHeroes.length)];
                    const damage = Math.max(1, enemy.atk - target.def + Math.floor(Math.random() * 5));
                    
                    // Jesus (first hero in divine party) is invincible in New Game+ mode
                    if (newGamePlus && target.name === "Jesus Christ") {
                        battle.log.push(`${enemy.name} attacks ${target.name} but the attack has no effect! Jesus is invincible!`);
                    } else {
                        target.hp -= damage;
                        battle.log.push(`${enemy.name} attacks ${target.name} for ${damage} damage!`);
                    }
                }
            });
            
            if (checkBattleEnd()) return;
            
            battle.currentHeroIndex = 0;
            battle.phase = 'menu';
            battle.log.push(`${heroes[0].name}'s turn!`);
            updateBattleUI();
        }

        function checkBattleEnd() {
            if (heroes.every(h => h.hp <= 0)) {
                battle.log.push('All heroes defeated!');
                updateBattleUI();
                setTimeout(() => endBattle(false), 2000);
                return true;
            } else if (battle.enemies.every(e => e.hp <= 0)) {
                battle.log.push(`Victory over ${battle.enemies[0].vice.name}!`);
                updateBattleUI();
                setTimeout(() => endBattle(true), 2000);
                return true;
            }
            return false;
        }

        function endBattle(won, fled = false) {
            document.getElementById('battle-ui').style.display = 'none';
            document.getElementById('battle-status').style.display = 'none';
            document.getElementById('enemy-status').style.display = 'none';
            battle.active = false;
            disposeBattleScene();
            
            if (fled) {
                gameState = 'explore';
                return;
            }
            
            if (won) {
                const viceName = battle.enemies[0].vice.name;
                const enemyToRemove = enemies.find(e => e.vice.name === viceName);
                if (enemyToRemove) {
                    scene.remove(enemyToRemove.mesh);
                    enemies = enemies.filter(e => e !== enemyToRemove);
                }
                
                // Check if this was a mythical creature or Epstein
                const isMythicalCreature = enemyToRemove && (enemyToRemove.isMythical || enemyToRemove.isEpstein);
                
                // Award virtue item for deadly sins
                if (DEADLY_SINS.includes(viceName) && !inventory.virtueItems.includes(viceName)) {
                    const virtueItem = VIRTUE_ITEMS[viceName];
                    inventory.virtueItems.push(viceName);
                    
                    if (virtueItem.atkBoost) inventory.atkBoost += virtueItem.atkBoost;
                    if (virtueItem.defBoost) inventory.defBoost += virtueItem.defBoost;
                    if (virtueItem.hpBoost) {
                        inventory.hpBoost += virtueItem.hpBoost;
                        heroes.forEach(h => h.maxHp += virtueItem.hpBoost);
                    }
                }
                
                if (viceName === "The Devil") {
                    showViceTeaching(battle.enemies[0].vice, () => {
                        showGameVictory();
                    });
                    return;
                }
                
                // Mythical creatures give special stat boosts and don't progress the level
                if (isMythicalCreature) {
                    // Give gold reward for defeating mythical creature
                    const goldReward = 50 + dungeonLevel * 10;
                    inventory.gold += goldReward;
                    
                    // Always give 3 Divine Elixirs for defeating mythical creatures
                    inventory.divineElixirs += 3;
                    
                    // Check if this mythical creature was already defeated (can't get stat boost twice)
                    const alreadyDefeated = defeatedMythicalCreatures.has(viceName);
                    
                    if (!alreadyDefeated) {
                        // Mark as defeated
                        defeatedMythicalCreatures.add(viceName);
                        
                        // Apply special stat boost for this mythical creature (first time only)
                        const mythicalReward = MYTHICAL_REWARDS[viceName];
                        if (mythicalReward) {
                            // Apply HP boost
                            if (mythicalReward.hpBoost) {
                                inventory.hpBoost += mythicalReward.hpBoost;
                                heroes.forEach(hero => {
                                    hero.maxHp += mythicalReward.hpBoost;
                                    hero.hp += mythicalReward.hpBoost; // Also heal them
                                });
                            }
                            
                            // Apply ATK boost
                            if (mythicalReward.atkBoost) {
                                inventory.atkBoost += mythicalReward.atkBoost;
                            }
                            
                            // Apply DEF boost
                            if (mythicalReward.defBoost) {
                                inventory.defBoost += mythicalReward.defBoost;
                            }
                            
                            // Show special reward screen (includes Divine Elixirs notification)
                            showMythicalReward(mythicalReward, goldReward, () => {
                                showViceTeaching(battle.enemies[0].vice, () => {
                                    gameState = 'explore';
                                });
                            });
                        } else {
                            showViceTeaching(battle.enemies[0].vice, () => {
                                showMessage(`Victory! Earned ${goldReward} gold from ${viceName}!`, 3000);
                                gameState = 'explore';
                            });
                        }
                    } else {
                        // Already defeated this creature - give gold and elixirs but not stat boost
                        showViceTeaching(battle.enemies[0].vice, () => {
                            showMessage(`Victory! Earned ${goldReward} gold + 3 Divine Elixirs from ${viceName}! (Already received stat boost)`, 4000);
                            gameState = 'explore';
                        });
                    }
                    return;
                }
                
                // Only deadly sins progress the level
                if (DEADLY_SINS.includes(viceName)) {
                    defeatedSins.add(viceName);
                    
                    if (defeatedSins.size >= 7) {
                        const virtueItem = VIRTUE_ITEMS[viceName];
                        showVirtueItemReceived(virtueItem, () => {
                            showViceTeaching(battle.enemies[0].vice, () => {
                                showMessage('All Sins defeated! The Devil awaits...', 4000);
                                dungeonLevel++;
                                // Level up heroes
                                const statGains = levelUpHeroes();
                                showMessage(`Level Up! ${statGains}`, 3000);
                                setTimeout(() => {
                                    generateDungeon(true);
                                    gameState = 'explore';
                                }, 3000);
                            });
                        });
                        return;
                    }
                    
                    dungeonLevel++;
                    
                    const virtueItem = VIRTUE_ITEMS[viceName];
                    showVirtueItemReceived(virtueItem, () => {
                        showViceTeaching(battle.enemies[0].vice, () => {
                            // Level up heroes
                            const statGains = levelUpHeroes();
                            showMessage(`Victory! Level ${dungeonLevel} - ${statGains}`, 4000);
                            setTimeout(() => {
                                generateDungeon();
                                gameState = 'explore';
                            }, 4000);
                        });
                    });
                } else {
                    // Other enemies (if any) don't progress the level
                    showViceTeaching(battle.enemies[0].vice, () => {
                        showMessage(`Victory! Continuing level ${dungeonLevel}...`, 3000);
                        gameState = 'explore';
                    });
                }
            } else {
                dungeonLevel = 1;
                defeatedSins.clear();
                defeatedMythicalCreatures.clear(); // Reset mythical creature defeats
                showMessage('Defeated! Starting over...', 3000);
                inventory.holyWater = 3;
                inventory.rosaries = 2;
                inventory.gold = 0;
                inventory.atkBoost = 0;
                inventory.defBoost = 0;
                inventory.hpBoost = 0;
                inventory.virtueItems = [];
                inventory.divineElixirs = 0;
                generateDungeon();
                gameState = 'explore';
            }
        }

        function showVirtueItemReceived(item, callback) {
            document.getElementById('quote-text').innerHTML = `
                <div style="color: #2ecc71; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                    ✨ VIRTUE ITEM RECEIVED! ✨
                </div>
                <div style="color: #f39c12; font-size: 18px; margin-bottom: 12px;">
                    ${item.name}
                </div>
                <div style="color: #ecf0f1; font-size: 14px; margin-bottom: 15px;">
                    ${item.effect}
                </div>
                <div style="color: #95a5a6; font-size: 12px; line-height: 1.4;">
                    This sacred item strengthens your heroes!
                </div>
            `;
            document.getElementById('quote-author').textContent = '';
            document.getElementById('quote-overlay').style.display = 'flex';
            
            const btn = document.getElementById('quote-continue');
            btn.textContent = 'Continue';
            const handler = () => {
                document.getElementById('quote-overlay').style.display = 'none';
                btn.removeEventListener('click', handler);
                callback();
            };
            btn.addEventListener('click', handler);
        }

        function showMythicalReward(reward, gold, callback) {
            document.getElementById('quote-text').innerHTML = `
                <div style="color: #ffd700; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                    ✝️ DIVINE BLESSING RECEIVED ✝️
                </div>
                <div style="color: #3498db; font-size: 17px; font-weight: bold; margin-bottom: 12px; line-height: 1.3;">
                    ${reward.name}
                </div>
                <div style="color: #ecf0f1; font-size: 13px; line-height: 1.6; margin-bottom: 15px; text-align: left;">
                    ${reward.description}
                </div>
                <div style="color: #2ecc71; font-size: 16px; font-weight: bold; margin-bottom: 10px;">
                    ${reward.effect}
                </div>
                <div style="color: #f39c12; font-size: 14px; margin-top: 12px;">
                    💰 +${gold} Gold
                </div>
                <div style="color: #3498db; font-size: 14px; margin-top: 8px;">
                    ✨ +3 Divine Elixirs (Full Party HP & MP Restore)
                </div>
                <div style="color: #9b59b6; font-size: 12px; line-height: 1.5; margin-top: 15px; font-style: italic;">
                    "Draw near to God, and He will draw near to you."
                </div>
                <div style="color: #95a5a6; font-size: 10px; margin-top: 5px;">
                    — James 4:8
                </div>
            `;
            document.getElementById('quote-author').textContent = '';
            document.getElementById('quote-overlay').style.display = 'flex';
            
            const btn = document.getElementById('quote-continue');
            btn.textContent = 'Continue';
            const handler = () => {
                document.getElementById('quote-overlay').style.display = 'none';
                btn.removeEventListener('click', handler);
                callback();
            };
            btn.addEventListener('click', handler);
        }

        function showViceTeaching(vice, callback) {
            document.getElementById('quote-text').innerHTML = `
                <div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 12px;">
                    ${vice.name} Defeated!
                </div>
                <div style="color: #ecf0f1; font-size: 13px; line-height: 1.5; text-align: left; margin-bottom: 15px;">
                    ${vice.catechism}
                </div>
                <div style="color: #3498db; font-size: 12px; font-style: italic; line-height: 1.4; text-align: left; margin-bottom: 8px;">
                    "${vice.verse}"
                </div>
                <div style="color: #f39c12; font-size: 11px; font-weight: bold;">
                    — ${vice.reference}
                </div>
            `;
            document.getElementById('quote-author').textContent = '';
            document.getElementById('quote-overlay').style.display = 'flex';
            
            const btn = document.getElementById('quote-continue');
            btn.textContent = 'Continue';
            const handler = () => {
                document.getElementById('quote-overlay').style.display = 'none';
                btn.removeEventListener('click', handler);
                callback();
            };
            btn.addEventListener('click', handler);
        }

        function showGameVictory() {
            // Create Garden of Eden scene
            createGardenOfEden();
        }

        let gardenScene = null;
        let gardenCamera = null;
        let jesusModel = null;
        let gardenPlayerModel = null;
        let gardenWalkProgress = 0;

        function createGardenOfEden() {
            try {
                gameState = 'garden';
                
                // Hide battle UI
                document.getElementById('battle-ui').style.display = 'none';
                document.getElementById('battle-status').style.display = 'none';
                document.getElementById('enemy-status').style.display = 'none';
                
                // Hide dungeon UI elements
                document.getElementById('hud').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                
                // Clear and hide the dungeon scene
                if (scene) {
                    // Hide the dungeon player model if it exists
                    if (playerModel && scene.children.includes(playerModel)) {
                        playerModel.visible = false;
                    }
                    // Hide all dungeon elements
                    scene.traverse((object) => {
                        if (object.isMesh) {
                            object.visible = false;
                        }
                    });
                }
                
                // Create garden scene with cinematic atmosphere
                gardenScene = new THREE.Scene();
                gardenScene.background = new THREE.Color(0xffd4a3); // Golden sky
                gardenScene.fog = new THREE.FogExp2(0xffd4a3, 0.008); // Atmospheric depth
                
                // Ground - photorealistic lush green grass (reduced for compact Garden)
                const groundGeometry = new THREE.PlaneGeometry(60, 60, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2d5016,
                    roughness: 0.95,
                    metalness: 0.0,
                    envMapIntensity: 0.3
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                gardenScene.add(ground);
                
                // Path with realistic dirt/stone texture (reduced for compact Garden)
                const pathGeometry = new THREE.PlaneGeometry(5, 60, 25, 25);
                const pathMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD2B48C,
                    roughness: 0.92,
                    metalness: 0.0,
                    envMapIntensity: 0.2
                });
                const path = new THREE.Mesh(pathGeometry, pathMaterial);
                path.rotation.x = -Math.PI / 2;
                path.position.y = 0.05;
                path.receiveShadow = true;
                gardenScene.add(path);
                
                console.log("Garden scene created, adding artifacts...");
                
                // ENTRANCE - Beatitudes Plaque at start
                createBeatitudesPlaque();
                
                // LEFT SIDE - Biblical Artifacts
                createTenCommandments(-5, 0, -8);  // Ten Commandments
                createStaffOfAaron(-5, 0, -14);    // Staff of Aaron
                createManna(-5, 0, -20);           // Manna from Heaven (NEW)
                createArkOfCovenant(-5, 0, -26);   // Ark of the Covenant
                
                // RIGHT SIDE - Biblical Figures
                createMosesStatue(5, 0, -8);       // Moses
                createElijahStatue(5, 0, -14);     // Elijah
                createMotherMaryStatue(5, 0, -20); // Mother Mary
                createAbrahamStatue(5, 0, -26);    // Abraham
                
                // CENTER - Nine Orders of Angels (NEW) - Row of 9 angels
                createAngelsRow(0, 0, -34);
                
                // END - Tree of Life and Cherubim Guardian
                createTreeOfLife(0, 0, -38);       // Tree of Life (biblically accurate)
                createCherubimStatue(0, 0, -42);   // Cherubim with Flaming Sword at the end
                
                // Four Rivers of Eden (biblically accurate from Genesis 2:10-14)
                createRiver(-15, 0, -20, "Pishon");
                createRiver(15, 0, -20, "Gihon");
                createRiver(-15, 0, -10, "Tigris");
                createRiver(15, 0, -10, "Euphrates");
                
                console.log("Artifacts added, adding vegetation...");
                
            // Remove Bible passage stands to keep it simpler and more compact
            
            // Reduced vegetation for 5-minute exploration
            // Oak trees - fewer but strategic placement
            for (let i = 0; i < 8; i++) {
                createOakTree(-10 + (i % 2) * 20, 0, -5 - i * 5);
            }
            
            // Palm trees - tropical beauty (reduced)
            for (let i = 0; i < 6; i++) {
                createPalmTree(-12 + (i % 2) * 24, 0, -10 - i * 6);
            }
            
            // Cypress trees - tall and elegant (reduced)
            for (let i = 0; i < 6; i++) {
                createCypressTree(10 + (i % 2) * -20, 0, -8 - i * 6);
            }
            
            // Fruit trees (apple, olive) - modest garden (reduced)
            for (let i = 0; i < 12; i++) {
                const x = -12 + (i % 3) * 12;
                const z = -5 - i * 3;
                if (i % 2 === 0) {
                    createFruitTree(x, 0, z, 0xFF0000); // Red apples
                } else {
                    createFruitTree(x, 0, z, 0x808000); // Olive
                }
            }
            
            // Beautiful flowers - modest Paradise garden (reduced from 400 to 100)
            const flowerTypes = [
                { color: 0xFF69B4, name: 'Rose' },
                { color: 0xFFFF00, name: 'Sunflower' },
                { color: 0xFF0000, name: 'Poppy' },
                { color: 0xFF00FF, name: 'Orchid' },
                { color: 0xFFA500, name: 'Marigold' },
                { color: 0x9370DB, name: 'Lavender' },
                { color: 0xFFFFFF, name: 'Lily' },
                { color: 0x0000FF, name: 'Bluebell' },
                { color: 0xFF1493, name: 'Carnation' }
            ];
            
            for (let i = 0; i < 100; i++) {
                const flowerType = flowerTypes[Math.floor(Math.random() * flowerTypes.length)];
                createFlower(
                    -20 + Math.random() * 40,
                    0.15,
                    -2 + Math.random() * -40,
                    flowerType.color
                );
            }
            
            // Bushes and shrubs - reduced
            for (let i = 0; i < 25; i++) {
                createBush(-18 + Math.random() * 36, 0, -2 - Math.random() * 40);
            }
            
            // Flowering vines - reduced
            for (let i = 0; i < 8; i++) {
                createVine(-12 + (i % 2) * 24, 0, -6 - i * 5);
            }
            
            // Garden rocks - reduced
            for (let i = 0; i < 20; i++) {
                createRock(-18 + Math.random() * 36, 0, -2 - Math.random() * 40);
            }
            
            // Lighting - Photorealistic golden hour lighting
            const ambientLight = new THREE.AmbientLight(0xffffee, 0.5);
            gardenScene.add(ambientLight);
            
            // Main sun with realistic color temperature
            const sunLight = new THREE.DirectionalLight(0xfff5e6, 3.0);
            sunLight.position.set(15, 30, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.left = -80;
            sunLight.shadow.camera.right = 80;
            sunLight.shadow.camera.top = 80;
            sunLight.shadow.camera.bottom = -80;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.bias = -0.00001;
            gardenScene.add(sunLight);
            
            // Hemisphere light for realistic sky/ground bounce lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x5D8C3E, 1.0);
            gardenScene.add(hemisphereLight);
            
            // Warm fill light (simulating bounced sunlight)
            const fillLight = new THREE.DirectionalLight(0xffe4b5, 0.8);
            fillLight.position.set(-10, 20, -10);
            gardenScene.add(fillLight);
            
            // Subtle rim light for depth
            const rimLight = new THREE.DirectionalLight(0xffd700, 0.4);
            rimLight.position.set(10, 10, -20);
            gardenScene.add(rimLight);
            
            // Create Jesus model at the end of the path
            jesusModel = createJesusModel();
            jesusModel.position.set(0, 0, -95);
            jesusModel.rotation.y = Math.PI;
            gardenScene.add(jesusModel);
            
            // Create player model
            gardenPlayerModel = createPlayerModel();
            gardenPlayerModel.position.set(0, 0, 5);
            gardenPlayerModel.rotation.y = Math.PI;
            gardenScene.add(gardenPlayerModel);
            
            // Camera setup
            gardenCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            gardenCamera.position.set(0, 2.5, 10);
            gardenCamera.lookAt(0, 1, 5);
            
            console.log("Garden of Eden created successfully!");
            console.log("Garden scene children count:", gardenScene.children.length);
            
            // Show victory message
            showVictoryMessage();
            } catch (error) {
                console.error("Error creating Garden of Eden:", error);
                console.error("Error stack:", error.stack);
                alert("Error creating Garden: " + error.message);
            }
        }

        function createBeatitudesPlaque() {
            // Stone plaque stand
            const standGeometry = new THREE.BoxGeometry(3, 3, 0.3);
            const standMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.set(0, 1.5, 2);
            stand.userData.type = 'beatitudes';
            stand.userData.clickable = true;
            gardenScene.add(stand);
            
            // Golden frame
            const frameGeometry = new THREE.BoxGeometry(3.2, 3.2, 0.2);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 1.5, 2.15);
            gardenScene.add(frame);
        }

        function createTenCommandments(x, y, z) {
            // Two stone tablets
            const tabletGeometry = new THREE.BoxGeometry(1.2, 2, 0.3);
            const tabletMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            
            const leftTablet = new THREE.Mesh(tabletGeometry, tabletMaterial);
            leftTablet.position.set(x - 0.7, y + 1, z);
            leftTablet.rotation.y = Math.PI / 8;
            leftTablet.userData.type = 'commandments';
            leftTablet.userData.clickable = true;
            gardenScene.add(leftTablet);
            
            const rightTablet = new THREE.Mesh(tabletGeometry, tabletMaterial);
            rightTablet.position.set(x + 0.7, y + 1, z);
            rightTablet.rotation.y = -Math.PI / 8;
            rightTablet.userData.type = 'commandments';
            rightTablet.userData.clickable = true;
            gardenScene.add(rightTablet);
            
            // Stone pedestal
            const pedestalGeometry = new THREE.CylinderGeometry(1.5, 1.8, 0.5, 8);
            const pedestalMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.set(x, y + 0.25, z);
            gardenScene.add(pedestal);
        }

        function createStaffOfAaron(x, y, z) {
            // Staff
            const staffGeometry = new THREE.CylinderGeometry(0.08, 0.08, 3, 8);
            const staffMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const staff = new THREE.Mesh(staffGeometry, staffMaterial);
            staff.position.set(x, y + 1.5, z);
            staff.rotation.z = Math.PI / 6;
            staff.userData.type = 'staff';
            staff.userData.clickable = true;
            gardenScene.add(staff);
            
            // Blossoming almond branches
            for (let i = 0; i < 5; i++) {
                const blossomGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const blossomMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFB6C1,
                    emissive: 0xFFB6C1,
                    emissiveIntensity: 0.3
                });
                const blossom = new THREE.Mesh(blossomGeometry, blossomMaterial);
                blossom.position.set(
                    x + Math.sin(staff.rotation.z) * (1 + i * 0.3),
                    y + 2 + i * 0.3,
                    z + Math.cos(staff.rotation.z) * (1 + i * 0.3)
                );
                gardenScene.add(blossom);
            }
            
            // Display stand
            const standGeometry = new THREE.CylinderGeometry(0.5, 0.6, 0.8, 8);
            const standMaterial = new THREE.MeshStandardMaterial({ color: 0xD4AF37 });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.set(x, y + 0.4, z);
            gardenScene.add(stand);
        }

        function createArkOfCovenant(x, y, z) {
            // Main ark box (golden)
            const arkGeometry = new THREE.BoxGeometry(2, 1.2, 1.2);
            const arkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xFFD700,
                emissiveIntensity: 0.2
            });
            const ark = new THREE.Mesh(arkGeometry, arkMaterial);
            ark.position.set(x, y + 1.5, z);
            ark.userData.type = 'ark';
            ark.userData.clickable = true;
            gardenScene.add(ark);
            
            // Mercy seat (lid)
            const lidGeometry = new THREE.BoxGeometry(2.2, 0.2, 1.3);
            const lid = new THREE.Mesh(lidGeometry, arkMaterial);
            lid.position.set(x, y + 2.2, z);
            gardenScene.add(lid);
            
            // Cherubim (angels on top)
            const cherubGeometry = new THREE.BoxGeometry(0.4, 0.8, 0.3);
            const leftCherub = new THREE.Mesh(cherubGeometry, arkMaterial);
            leftCherub.position.set(x - 0.6, y + 2.7, z);
            gardenScene.add(leftCherub);
            
            const rightCherub = new THREE.Mesh(cherubGeometry, arkMaterial);
            rightCherub.position.set(x + 0.6, y + 2.7, z);
            gardenScene.add(rightCherub);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.5);
            const leftWing = new THREE.Mesh(wingGeometry, arkMaterial);
            leftWing.position.set(x - 0.3, y + 2.9, z);
            leftWing.rotation.z = -Math.PI / 4;
            gardenScene.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, arkMaterial);
            rightWing.position.set(x + 0.3, y + 2.9, z);
            rightWing.rotation.z = Math.PI / 4;
            gardenScene.add(rightWing);
            
            // Pedestal
            const pedestalGeometry = new THREE.CylinderGeometry(1.5, 1.8, 1, 8);
            const pedestalMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.set(x, y + 0.5, z);
            gardenScene.add(pedestal);
        }

        function createMosesStatue(x, y, z) {
            const group = new THREE.Group();
            
            // Robes
            const robeGeometry = new THREE.BoxGeometry(1, 1.8, 0.8);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 1;
            group.add(robe);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.1;
            group.add(head);
            
            // Long beard
            const beardGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
            const beardMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3 });
            const beard = new THREE.Mesh(beardGeometry, beardMaterial);
            beard.position.y = 1.5;
            beard.position.z = 0.3;
            group.add(beard);
            
            // Staff in hand
            const staffGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8);
            const staffMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const staff = new THREE.Mesh(staffGeometry, staffMaterial);
            staff.position.set(0.6, 1.5, 0);
            group.add(staff);
            
            group.position.set(x, y, z);
            group.userData.type = 'moses';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createElijahStatue(x, y, z) {
            const group = new THREE.Group();
            
            // Robes (darker, weathered prophet's garb)
            const robeGeometry = new THREE.BoxGeometry(1, 1.8, 0.8);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 1;
            group.add(robe);
            
            // Mantle/Cloak (distinctive feature of Elijah)
            const mantleGeometry = new THREE.BoxGeometry(1.3, 1.2, 0.2);
            const mantleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x6D4C41,
                roughness: 0.9
            });
            const mantle = new THREE.Mesh(mantleGeometry, mantleMaterial);
            mantle.position.set(0, 1.2, -0.4);
            group.add(mantle);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.1;
            group.add(head);
            
            // Wild beard (Elijah lived in wilderness)
            const beardGeometry = new THREE.BoxGeometry(0.7, 0.9, 0.5);
            const beardMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
            const beard = new THREE.Mesh(beardGeometry, beardMaterial);
            beard.position.y = 1.5;
            beard.position.z = 0.3;
            group.add(beard);
            
            // Wild hair
            const hairGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.7);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 2.4;
            group.add(hair);
            
            // Staff/Walking stick
            const staffGeometry = new THREE.CylinderGeometry(0.06, 0.06, 2.3, 8);
            const staffMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const staff = new THREE.Mesh(staffGeometry, staffMaterial);
            staff.position.set(0.6, 1.4, 0);
            group.add(staff);
            
            // Flame symbol (Elijah called down fire from heaven)
            const flameGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const flameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff6600,
                emissive: 0xff6600,
                emissiveIntensity: 0.6
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(-0.6, 1.5, 0.3);
            group.add(flame);
            
            // Add glow to flame
            const flameLight = new THREE.PointLight(0xff6600, 0.5, 3);
            flameLight.position.set(-0.6, 1.5, 0.3);
            group.add(flameLight);
            
            group.position.set(x, y, z);
            group.userData.type = 'elijah';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createMotherMaryStatue(x, y, z) {
            const group = new THREE.Group();
            
            // Blue robes
            const robeGeometry = new THREE.BoxGeometry(1, 1.8, 0.8);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 1;
            group.add(robe);
            
            // White veil
            const veilGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.7);
            const veilMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const veil = new THREE.Mesh(veilGeometry, veilMaterial);
            veil.position.y = 2.3;
            group.add(veil);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.0;
            group.add(head);
            
            // Praying hands
            const handGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.2);
            const handMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const hands = new THREE.Mesh(handGeometry, handMaterial);
            hands.position.set(0, 1.2, 0.5);
            group.add(hands);
            
            // Halo
            const haloGeometry = new THREE.TorusGeometry(0.4, 0.04, 8, 16);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.6
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 2.5;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            group.position.set(x, y, z);
            group.userData.type = 'mary';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createAbrahamStatue(x, y, z) {
            const group = new THREE.Group();
            
            // Ancient robes - earth tones
            const robeGeometry = new THREE.BoxGeometry(1, 1.8, 0.8);
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 1;
            group.add(robe);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0c291 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.1;
            group.add(head);
            
            // Long white beard (father of faith)
            const beardGeometry = new THREE.BoxGeometry(0.6, 0.9, 0.4);
            const beardMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
            const beard = new THREE.Mesh(beardGeometry, beardMaterial);
            beard.position.y = 1.5;
            beard.position.z = 0.3;
            group.add(beard);
            
            // Walking staff
            const staffGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8);
            const staffMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const staff = new THREE.Mesh(staffGeometry, staffMaterial);
            staff.position.set(0.6, 1.5, 0);
            group.add(staff);
            
            // Turban/head covering
            const turbanGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 8);
            const turbanMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
            const turban = new THREE.Mesh(turbanGeometry, turbanMaterial);
            turban.position.y = 2.45;
            group.add(turban);
            
            group.position.set(x, y, z);
            group.userData.type = 'abraham';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createBiblePassageStand(x, y, z, title, text, reference) {
            // Wooden stand
            const standGeometry = new THREE.BoxGeometry(2, 1.5, 0.2);
            const standMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.set(x, y + 1.2, z);
            stand.rotation.y = x < 0 ? Math.PI / 4 : -Math.PI / 4;
            stand.userData.type = 'passage';
            stand.userData.clickable = true;
            stand.userData.title = title;
            stand.userData.text = text;
            stand.userData.reference = reference;
            gardenScene.add(stand);
            
            // Post
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
            const post = new THREE.Mesh(postGeometry, standMaterial);
            post.position.set(x, y + 0.75, z);
            gardenScene.add(post);
        }

        function createCherubimStatue(x, y, z) {
            const group = new THREE.Group();
            
            // Cherubim body (angelic figure)
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5dc, // Beige/cream
                roughness: 0.6,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 1.5, 0);
            body.castShadow = true;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 2.7, 0);
            head.castShadow = true;
            group.add(head);
            
            // Glowing halo
            const haloGeometry = new THREE.TorusGeometry(0.4, 0.05, 8, 32);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffeb3b,
                emissive: 0xffeb3b,
                emissiveIntensity: 1.5,
                metalness: 0.5,
                roughness: 0.3
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 3.2, 0);
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            // Wings (two large wings)
            const wingGeometry = new THREE.BoxGeometry(1.5, 1.8, 0.1);
            const wingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-1, 2, 0);
            leftWing.rotation.y = Math.PI / 6;
            leftWing.castShadow = true;
            group.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(1, 2, 0);
            rightWing.rotation.y = -Math.PI / 6;
            rightWing.castShadow = true;
            group.add(rightWing);
            
            // FLAMING SWORD - The Key Feature
            const swordHandleGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8);
            const swordHandleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const swordHandle = new THREE.Mesh(swordHandleGeo, swordHandleMat);
            swordHandle.position.set(0.5, 1.5, 0);
            swordHandle.rotation.z = Math.PI / 4;
            group.add(swordHandle);
            
            const swordBladeGeo = new THREE.BoxGeometry(0.15, 1.5, 0.05);
            const swordBladeMat = new THREE.MeshStandardMaterial({ 
                color: 0xc0c0c0,
                metalness: 0.9,
                roughness: 0.2
            });
            const swordBlade = new THREE.Mesh(swordBladeGeo, swordBladeMat);
            swordBlade.position.set(0.5, 2.5, 0);
            swordBlade.rotation.z = Math.PI / 4;
            group.add(swordBlade);
            
            // FLAMES on the sword
            const flameGeometry = new THREE.ConeGeometry(0.25, 0.8, 8);
            const flameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4500,
                emissive: 0xff4500,
                emissiveIntensity: 2,
                transparent: true,
                opacity: 0.8
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0.5, 3.3, 0);
            flame.rotation.z = Math.PI / 4;
            group.add(flame);
            
            // Flame light
            const flameLight = new THREE.PointLight(0xff4500, 1.5, 5);
            flameLight.position.set(0.5, 3.3, 0);
            group.add(flameLight);
            
            group.position.set(x, y, z);
            group.userData.type = 'cherubim';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createManna(x, y, z) {
            const group = new THREE.Group();
            
            // Golden jar/pot for manna
            const jarGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.8, 16);
            const jarMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xDAA520,
                metalness: 0.8,
                roughness: 0.3,
                emissive: 0xDAA520,
                emissiveIntensity: 0.3
            });
            const jar = new THREE.Mesh(jarGeometry, jarMaterial);
            jar.position.y = 1.2;
            group.add(jar);
            
            // Lid
            const lidGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.2, 16);
            const lid = new THREE.Mesh(lidGeometry, jarMaterial);
            lid.position.y = 1.7;
            group.add(lid);
            
            // Pedestal
            const pedestalGeometry = new THREE.CylinderGeometry(0.6, 0.7, 0.8, 8);
            const pedestalMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.y = 0.4;
            group.add(pedestal);
            
            // Glowing particles above jar (representing manna)
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const particleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFE0,
                    emissive: 0xFFFFE0,
                    emissiveIntensity: 1.0
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    Math.random() * 0.6 - 0.3,
                    1.8 + Math.random() * 0.5,
                    Math.random() * 0.6 - 0.3
                );
                group.add(particle);
            }
            
            // Soft glow
            const glowLight = new THREE.PointLight(0xFFFFE0, 1, 3);
            glowLight.position.y = 1.8;
            group.add(glowLight);
            
            group.position.set(x, y, z);
            group.userData.type = 'manna';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createTreeOfLife(x, y, z) {
            const group = new THREE.Group();
            
            // Large trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 5, 12);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.95
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            group.add(trunk);
            
            // Golden glowing canopy
            const canopyGeometry = new THREE.SphereGeometry(3, 16, 16);
            const canopyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90EE90,
                emissive: 0xFFD700,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.y = 6;
            group.add(canopy);
            
            // Glowing fruit (12 fruits for 12 months - Revelation 22:2)
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const fruitGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const fruitMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 1.0
                });
                const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
                fruit.position.set(
                    Math.cos(angle) * 2.5,
                    5 + Math.sin(i * 0.5) * 1,
                    Math.sin(angle) * 2.5
                );
                group.add(fruit);
            }
            
            // Radiant light from the tree
            const treeLight = new THREE.PointLight(0xFFD700, 3, 15);
            treeLight.position.y = 6;
            group.add(treeLight);
            
            group.position.set(x, y, z);
            group.userData.type = 'tree_of_life';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createAngelsRow(x, y, z) {
            // Create 9 angel statues representing the 9 orders of angels
            const spacing = 3;
            const startX = x - 12; // Center the row
            
            const angelNames = ['Seraphim', 'Cherubim', 'Thrones', 'Dominions', 'Virtues', 'Powers', 'Principalities', 'Archangels', 'Angels'];
            
            for (let i = 0; i < 9; i++) {
                const angelX = startX + i * spacing;
                createAngelStatue(angelX, y, z, angelNames[i]);
            }
        }

        function createAngelStatue(x, y, z, orderName) {
            const group = new THREE.Group();
            
            // Angelic robes - white/cream
            const robeGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
            const robeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFAFA,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.2
            });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.8;
            group.add(robe);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 12, 12);
            const head = new THREE.Mesh(headGeometry, robeMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            // Golden halo
            const haloGeometry = new THREE.TorusGeometry(0.25, 0.04, 8, 16);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 1.0
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 2.0;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(0.8, 1.0, 0.05);
            const wingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.6, 1.2, 0);
            leftWing.rotation.y = Math.PI / 6;
            group.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.6, 1.2, 0);
            rightWing.rotation.y = -Math.PI / 6;
            group.add(rightWing);
            
            group.position.set(x, y, z);
            group.userData.type = 'angels';
            group.userData.orderName = orderName;
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        function createRiver(x, y, z, riverName) {
            // Create flowing water representation
            const riverGeometry = new THREE.PlaneGeometry(2, 8);
            const riverMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169E1,
                transparent: true,
                opacity: 0.7,
                emissive: 0x87CEEB,
                emissiveIntensity: 0.3,
                roughness: 0.1,
                metalness: 0.5
            });
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            river.rotation.x = -Math.PI / 2;
            river.position.set(x, y + 0.02, z);
            river.userData.type = 'river';
            river.userData.riverName = riverName;
            river.userData.clickable = true;
            gardenScene.add(river);
        }

        function createOpenBible(x, y, z) {
            const group = new THREE.Group();
            
            // Pedestal
            const pedestalGeometry = new THREE.CylinderGeometry(0.5, 0.6, 0.8, 8);
            const pedestalMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b7355,
                roughness: 0.8,
                metalness: 0.1
            });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.set(0, 0.4, 0);
            pedestal.castShadow = true;
            group.add(pedestal);
            
            // Open book (two pages)
            const pageGeometry = new THREE.BoxGeometry(0.8, 0.02, 0.6);
            const pageMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5dc,
                roughness: 0.9,
                metalness: 0
            });
            
            const leftPage = new THREE.Mesh(pageGeometry, pageMaterial);
            leftPage.position.set(-0.4, 0.81, 0);
            leftPage.rotation.z = -0.2;
            leftPage.castShadow = true;
            group.add(leftPage);
            
            const rightPage = new THREE.Mesh(pageGeometry, pageMaterial);
            rightPage.position.set(0.4, 0.81, 0);
            rightPage.rotation.z = 0.2;
            rightPage.castShadow = true;
            group.add(rightPage);
            
            // Book spine
            const spineGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.6);
            const spineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.7,
                metalness: 0.1
            });
            const spine = new THREE.Mesh(spineGeometry, spineMaterial);
            spine.position.set(0, 0.83, 0);
            group.add(spine);
            
            // Glow around bible
            const glowLight = new THREE.PointLight(0xffffff, 0.8, 4);
            glowLight.position.set(0, 1, 0);
            group.add(glowLight);
            
            group.position.set(x, y, z);
            group.userData.type = 'openbible';
            group.userData.clickable = true;
            gardenScene.add(group);
        }

        // TREE CREATION FUNCTIONS
        function createOakTree(x, y, z) {
            // Realistic bark texture
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.5, 4, 32);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x6B4423,
                roughness: 0.98,
                metalness: 0.0,
                envMapIntensity: 0.1
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 2, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            gardenScene.add(trunk);
            
            // Realistic dense foliage with subsurface scattering look
            const canopyGeometry = new THREE.SphereGeometry(2.5, 32, 32);
            const canopyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d5016,
                roughness: 0.85,
                metalness: 0.0,
                envMapIntensity: 0.5
            });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.set(x, y + 5.5, z);
            canopy.castShadow = true;
            canopy.receiveShadow = true;
            gardenScene.add(canopy);
        }

        function createPalmTree(x, y, z) {
            // Tall slender trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.25, 6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0xD2691E });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 3, z);
            trunk.castShadow = true;
            gardenScene.add(trunk);
            
            // Palm fronds
            const frondGeometry = new THREE.BoxGeometry(0.3, 2, 0.1);
            const frondMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            
            for (let i = 0; i < 8; i++) {
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                const angle = (i / 8) * Math.PI * 2;
                frond.position.set(
                    x + Math.cos(angle) * 0.5,
                    y + 6.5,
                    z + Math.sin(angle) * 0.5
                );
                frond.rotation.y = angle;
                frond.rotation.z = Math.PI / 4;
                gardenScene.add(frond);
            }
        }

        function createCypressTree(x, y, z) {
            // Tall thin trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 2.5, z);
            trunk.castShadow = true;
            gardenScene.add(trunk);
            
            // Cone-shaped foliage
            const foliageGeometry = new THREE.ConeGeometry(1, 4, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x355E3B });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(x, y + 5.5, z);
            foliage.castShadow = true;
            gardenScene.add(foliage);
        }

        function createFruitTree(x, y, z, fruitColor) {
            // Medium trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.35, 3, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 1.5, z);
            trunk.castShadow = true;
            gardenScene.add(trunk);
            
            // Leafy canopy
            const canopyGeometry = new THREE.SphereGeometry(1.5, 8, 8);
            const canopyMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90 });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.set(x, y + 3.5, z);
            canopy.castShadow = true;
            gardenScene.add(canopy);
            
            // Fruit
            for (let i = 0; i < 6; i++) {
                const fruitGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const fruitMaterial = new THREE.MeshStandardMaterial({ color: fruitColor });
                const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
                fruit.position.set(
                    x + (Math.random() - 0.5) * 2,
                    y + 3 + Math.random(),
                    z + (Math.random() - 0.5) * 2
                );
                gardenScene.add(fruit);
            }
        }

        function createFlower(x, y, z, color) {
            // Realistic stem
            const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16);
            const stemMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8,
                metalness: 0.0
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.set(x, y - 0.1, z);
            stem.castShadow = true;
            gardenScene.add(stem);
            
            // Center of flower
            const flowerGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const flowerMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.4,
                metalness: 0.0,
                emissive: color,
                emissiveIntensity: 0.15,
                envMapIntensity: 0.6
            });
            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
            flower.position.set(x, y, z);
            flower.castShadow = true;
            gardenScene.add(flower);
            
            // Realistic petals with translucent appearance
            for (let i = 0; i < 5; i++) {
                const petalGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const petalMaterial = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.3,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 0.7
                });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                const angle = (i / 5) * Math.PI * 2;
                petal.position.set(
                    x + Math.cos(angle) * 0.08,
                    y,
                    z + Math.sin(angle) * 0.08
                );
                petal.castShadow = true;
                gardenScene.add(petal);
            }
        }

        function createBush(x, y, z) {
            const bushGeometry = new THREE.SphereGeometry(0.6, 8, 6);
            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x2F4F2F });
            const bush = new THREE.Mesh(bushGeometry, bushMaterial);
            bush.position.set(x, y + 0.4, z);
            bush.scale.set(1, 0.7, 1);
            bush.castShadow = true;
            gardenScene.add(bush);
        }

        function createVine(x, y, z) {
            // Climbing support
            const supportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
            const supportMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const support = new THREE.Mesh(supportGeometry, supportMaterial);
            support.position.set(x, y + 1.5, z);
            gardenScene.add(support);
            
            // Vine leaves
            for (let i = 0; i < 10; i++) {
                const leafGeometry = new THREE.SphereGeometry(0.15, 6, 6);
                const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(
                    x + Math.sin(i * 0.5) * 0.3,
                    y + 0.3 + i * 0.3,
                    z + Math.cos(i * 0.5) * 0.3
                );
                gardenScene.add(leaf);
            }
            
            // Purple flowering vine
            for (let i = 0; i < 5; i++) {
                const flowerGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                const flowerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x9370DB,
                    emissive: 0x9370DB,
                    emissiveIntensity: 0.3
                });
                const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                flower.position.set(
                    x + Math.sin(i * 0.7) * 0.3,
                    y + 0.5 + i * 0.5,
                    z + Math.cos(i * 0.7) * 0.3
                );
                gardenScene.add(flower);
            }
        }

        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.3, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, y + 0.2, z);
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.castShadow = true;
            gardenScene.add(rock);
        }

        function createJesusModel() {
            const group = new THREE.Group();
            
            // Body (pure white robe with soft glow)
            const bodyGeometry = new THREE.CylinderGeometry(0.35, 0.45, 0.9, 32);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.4,
                metalness: 0.0,
                emissive: 0xffffff,
                emissiveIntensity: 0.15,
                envMapIntensity: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Head (realistic skin)
            const headGeometry = new THREE.SphereGeometry(0.22, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0c291,
                roughness: 0.5,
                metalness: 0.0,
                envMapIntensity: 0.4
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.2;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // Hair and beard (flowing brown hair)
            const hairGeometry = new THREE.SphereGeometry(0.24, 32, 32);
            hairGeometry.scale(1, 1.2, 1);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.95,
                metalness: 0.0
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.25;
            hair.castShadow = true;
            group.add(hair);
            
            // Halo (radiant golden ring with bloom effect)
            const haloGeometry = new THREE.TorusGeometry(0.35, 0.04, 16, 64);
            const haloMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0xffd700,
                emissiveIntensity: 1.5
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 1.6;
            halo.rotation.x = Math.PI / 2;
            group.add(halo);
            
            // Add point light for halo glow
            const haloLight = new THREE.PointLight(0xffd700, 0.8, 3);
            haloLight.position.y = 1.6;
            group.add(haloLight);
            
            // Arms extended in welcome (cylindrical for realism)
            const armGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.6, 16);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.4,
                metalness: 0.0
            });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.7, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            group.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.07, 0.5, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.0
            });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.15, 0);
            leftLeg.castShadow = true;
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.15, 0);
            rightLeg.castShadow = true;
            group.add(leftLeg);
            group.add(rightLeg);
            
            return group;
        }

        function showVictoryMessage() {
            document.getElementById('quote-text').innerHTML = `
                <div style="color: #f1c40f; font-size: 24px; font-weight: bold; margin-bottom: 15px;">
                    🏆 VICTORY! 🏆
                </div>
                <div style="color: #2ecc71; font-size: 16px; margin-bottom: 15px;">
                    The Devil has been vanquished!<br>
                    Light triumphs over darkness!
                </div>
                <div style="color: #ecf0f1; font-size: 14px; margin-bottom: 15px;">
                    You may now explore the Garden of Eden freely
                </div>
                <div style="color: #ecf0f1; font-size: 13px; font-style: italic; line-height: 1.5; margin-bottom: 10px;">
                    "For I am convinced that neither death nor life, neither angels nor demons, 
                    nor anything else in all creation, will be able to separate us from the love 
                    of God that is in Christ Jesus our Lord."
                </div>
                <div style="color: #f39c12; font-size: 12px; font-weight: bold;">
                    — Romans 8:38-39
                </div>
            `;
            document.getElementById('quote-author').textContent = '';
            document.getElementById('quote-overlay').style.display = 'flex';
            
            // Auto-hide after 4 seconds and start free roam
            setTimeout(() => {
                document.getElementById('quote-overlay').style.display = 'none';
                startGardenWalk();
            }, 4000);
        }

        function startGardenWalk() {
            gardenWalkProgress = 0;
            enableGardenInteraction();
            // Garden walk will be animated in the update loop
        }

        function updateGardenWalk(dt) {
            if (gameState !== 'garden' || !gardenScene || !gardenCamera) return;
            
            // Use the stored garden player model
            if (!gardenPlayerModel) return;
            
            // FREE ROAM MOVEMENT - WASD controls
            const moveSpeed = 0.1;
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            gardenCamera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(gardenCamera.up, forward).normalize();
            
            let hasMoved = false;
            
            // Keyboard movement
            if (keys['w']) {
                gardenPlayerModel.position.x += forward.x * moveSpeed;
                gardenPlayerModel.position.z += forward.z * moveSpeed;
                hasMoved = true;
            }
            if (keys['s']) {
                gardenPlayerModel.position.x -= forward.x * moveSpeed;
                gardenPlayerModel.position.z -= forward.z * moveSpeed;
                hasMoved = true;
            }
            if (keys['a']) {
                gardenPlayerModel.position.x += right.x * moveSpeed;
                gardenPlayerModel.position.z += right.z * moveSpeed;
                hasMoved = true;
            }
            if (keys['d']) {
                gardenPlayerModel.position.x -= right.x * moveSpeed;
                gardenPlayerModel.position.z -= right.z * moveSpeed;
                hasMoved = true;
            }
            
            // Mobile joystick movement
            if (movementJoystick.active) {
                gardenPlayerModel.position.x += right.x * movementJoystick.deltaX * moveSpeed;
                gardenPlayerModel.position.z += right.z * movementJoystick.deltaX * moveSpeed;
                gardenPlayerModel.position.x -= forward.x * movementJoystick.deltaY * moveSpeed;
                gardenPlayerModel.position.z -= forward.z * movementJoystick.deltaY * moveSpeed;
                hasMoved = true;
            }
            
            // Rotate player to face movement direction
            if (hasMoved) {
                const moveDir = new THREE.Vector3(forward.x, 0, forward.z);
                if (keys['s']) moveDir.multiplyScalar(-1);
                gardenPlayerModel.rotation.y = Math.atan2(moveDir.x, moveDir.z);
            }
            
            // Keep Jesus model in place if it exists
            if (jesusModel) {
                jesusModel.position.set(0, 0, -5);
                jesusModel.rotation.y = Math.PI;
            }
            
            // Camera follows player in third-person
            const cameraDistance = 4;
            const cameraHeight = 3;
            const targetCameraX = gardenPlayerModel.position.x - Math.sin(gardenCamera.rotation.y) * cameraDistance;
            const targetCameraZ = gardenPlayerModel.position.z - Math.cos(gardenCamera.rotation.y) * cameraDistance;
            
            gardenCamera.position.x = targetCameraX;
            gardenCamera.position.y = gardenPlayerModel.position.y + cameraHeight;
            gardenCamera.position.z = targetCameraZ;
            gardenCamera.lookAt(gardenPlayerModel.position.x, gardenPlayerModel.position.y + 1, gardenPlayerModel.position.z);
            
            // Mobile camera rotation
            if (cameraJoystick.active) {
                gardenCamera.rotation.y -= cameraJoystick.deltaX * 0.05;
            }
            
            // Check for nearby interactables (for interact button - works for both desktop and mobile)
            if (gameState === 'garden') {
                nearestInteractable = null;
                let closestDistance = 5; // Max interaction distance
                
                gardenScene.children.forEach(child => {
                    if (child.userData && child.userData.clickable) {
                        const distance = gardenPlayerModel.position.distanceTo(child.position);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            nearestInteractable = child.userData;
                        }
                    }
                });
                
                // Show/hide interact button based on proximity
                const interactBtn = document.getElementById('mobile-interact-btn');
                if (nearestInteractable) {
                    interactBtn.style.display = 'flex';
                    interactBtn.textContent = 'INTERACT';
                } else {
                    interactBtn.style.display = 'none';
                }
            }
        }

        // Click handler for garden objects
        function onGardenClick(event) {
            if (gameState !== 'garden') return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(new THREE.Vector2(x, y), gardenCamera);
            const intersects = raycaster.intersectObjects(gardenScene.children, true);
            
            for (let intersect of intersects) {
                let obj = intersect.object;
                
                // Check userData on object or its parent
                while (obj) {
                    if (obj.userData && obj.userData.clickable) {
                        showGardenDialog(obj.userData.type, obj.userData);
                        return;
                    }
                    obj = obj.parent;
                }
            }
        }

        function showGardenDialog(type, data) {
            let content = '';
            
            if (type === 'beatitudes') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        THE BEATITUDES
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        Blessed are the poor in spirit, for theirs is the kingdom of heaven.<br>
                        Blessed are those who mourn, for they will be comforted.<br>
                        Blessed are the meek, for they will inherit the earth.<br>
                        Blessed are those who hunger and thirst for righteousness, for they will be filled.<br>
                        Blessed are the merciful, for they will be shown mercy.<br>
                        Blessed are the pure in heart, for they will see God.<br>
                        Blessed are the peacemakers, for they will be called children of God.<br>
                        Blessed are those who are persecuted because of righteousness, for theirs is the kingdom of heaven.
                    </div>
                    <div style="color: #f39c12; font-size: 12px; font-weight: bold;">
                        — Matthew 5:3-10
                    </div>
                `;
            } else if (type === 'commandments') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        THE TEN COMMANDMENTS
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        1. I am the LORD your God; you shall have no other gods before me.<br>
                        2. You shall not take the name of the LORD your God in vain.<br>
                        3. Remember the Sabbath day, to keep it holy.<br>
                        4. Honor your father and your mother.<br>
                        5. You shall not murder.<br>
                        6. You shall not commit adultery.<br>
                        7. You shall not steal.<br>
                        8. You shall not bear false witness against your neighbor.<br>
                        9. You shall not covet your neighbor's wife.<br>
                        10. You shall not covet your neighbor's goods.
                    </div>
                    <div style="color: #f39c12; font-size: 12px; font-weight: bold;">
                        — Exodus 20:1-17
                    </div>
                `;
            } else if (type === 'staff') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        THE STAFF OF AARON
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "The next day Moses entered the tent and saw that Aaron's staff, which represented the tribe of Levi, had not only sprouted but had budded, blossomed and produced almonds. Then Moses brought out all the staffs from the LORD's presence to all the Israelites. They looked at them, and each of the leaders took his own staff."
                    </div>
                    <div style="color: #95a5a6; font-size: 12px; line-height: 1.5; margin-bottom: 10px;">
                        Aaron's staff that budded was a sign of God's chosen priesthood, demonstrating His divine selection of Aaron and his descendants for priestly service.
                    </div>
                    <div style="color: #f39c12; font-size: 12px; font-weight: bold;">
                        — Numbers 17:8-9
                    </div>
                `;
            } else if (type === 'ark') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        THE ARK OF THE COVENANT
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Have them make an ark of acacia wood—two and a half cubits long, a cubit and a half wide, and a cubit and a half high. Overlay it with pure gold, both inside and out, and make a gold molding around it. There, above the cover between the two cherubim that are over the ark of the covenant law, I will meet with you and give you all my commands for the Israelites."
                    </div>
                    <div style="color: #95a5a6; font-size: 12px; line-height: 1.5; margin-bottom: 10px;">
                        The Ark contained the stone tablets of the Ten Commandments, Aaron's staff, and a jar of manna. It represented God's presence among His people.
                    </div>
                    <div style="color: #f39c12; font-size: 12px; font-weight: bold;">
                        — Exodus 25:10-11, 22
                    </div>
                `;
            } else if (type === 'moses') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        MOSES SPEAKS
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"Hear, O Israel: The LORD our God, the LORD is one. Love the LORD your God with all your heart and with all your soul and with all your strength."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Deuteronomy 6:4-5 (The Shema)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "The LORD bless you and keep you; the LORD make his face shine on you and be gracious to you; the LORD turn his face toward you and give you peace."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Numbers 6:24-26 (Priestly Blessing)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "I have set before you life and death, blessings and curses. Now choose life, so that you and your children may live and that you may love the LORD your God, listen to his voice, and hold fast to him."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Deuteronomy 30:19-20</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        Moses, who saw the burning bush, parted the Red Sea, and received the Law on Mount Sinai, speaks these eternal words to guide God's people.
                    </div>
                `;
            } else if (type === 'elijah') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        ELIJAH THE PROPHET SPEAKS
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"How long will you waver between two opinions? If the LORD is God, follow him; but if Baal is God, follow him."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— 1 Kings 18:21 (Challenge at Mount Carmel)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Answer me, LORD, answer me, so these people will know that you, LORD, are God, and that you are turning their hearts back again." Then the fire of the LORD fell and burned up the sacrifice, the wood, the stones and the soil, and also licked up the water in the trench.
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— 1 Kings 18:37-38 (Fire from Heaven)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        The LORD said, "Go out and stand on the mountain in the presence of the LORD, for the LORD is about to pass by." A great and powerful wind tore the mountains apart, but the LORD was not in the wind. After the wind there was an earthquake, but the LORD was not in the earthquake. After the earthquake came a fire, but the LORD was not in the fire. And after the fire came a gentle whisper.
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— 1 Kings 19:11-12 (The Still Small Voice)</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        Elijah, the fiery prophet who called down fire from heaven, defeated the prophets of Baal, and was taken to heaven in a whirlwind, reminds us to listen for God's gentle whisper.
                    </div>
                `;
            } else if (type === 'mary') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        MOTHER MARY SPEAKS
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"I am the Lord's servant. May your word to me be fulfilled."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Luke 1:38 (The Annunciation)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "My soul glorifies the Lord and my spirit rejoices in God my Savior, for he has been mindful of the humble state of his servant. From now on all generations will call me blessed, for the Mighty One has done great things for me—holy is his name."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Luke 1:46-49 (The Magnificat)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Do whatever He tells you."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— John 2:5 (Wedding at Cana)</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        Mary, the Mother of God, whose "yes" to the angel Gabriel brought our Savior into the world, always points us to her Son and says: "Do whatever He tells you."
                    </div>
                `;
            } else if (type === 'abraham') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        ABRAHAM, FATHER OF FAITH, SPEAKS
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"I will make you into a great nation, and I will bless you; I will make your name great, and you will be a blessing. I will bless those who bless you, and whoever curses you I will curse; and all peoples on earth will be blessed through you."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Genesis 12:2-3 (God's Covenant with Abraham)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Do not lay a hand on the boy," the angel said. "Do not do anything to him. Now I know that you fear God, because you have not withheld from me your son, your only son." Through your offspring all nations on earth will be blessed, because you have obeyed me.
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Genesis 22:12, 18 (The Sacrifice of Isaac)</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        Against all hope, Abraham in hope believed and so became the father of many nations. Without weakening in his faith, he faced the fact that his body was as good as dead. Yet he did not waver through unbelief regarding the promise of God, but was strengthened in his faith and gave glory to God.
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Romans 4:18-20 (Abraham's Faith)</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        Abraham, who left his homeland by faith, believed God's impossible promises, and was willing to sacrifice his beloved son Isaac, stands as the father of all who believe.
                    </div>
                `;
            } else if (type === 'cherubim') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        ⚔️ THE CHERUBIM GUARDIAN ⚔️
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: center; margin-bottom: 15px;">
                        The angel stands at the eastern gate with a flaming sword, guarding the way to the Tree of Life.
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "After he drove the man out, he placed on the east side of the Garden of Eden cherubim and a flaming sword flashing back and forth to guard the way to the tree of life."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 15px;">— Genesis 3:24</div>
                    <div style="color: #2ecc71; font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 15px;">
                        "Would you like to continue exploring this peaceful garden, or begin a new journey?"
                    </div>
                `;
                
                // Special handling for Cherubim - offer choices
                document.getElementById('quote-text').innerHTML = content;
                document.getElementById('quote-author').textContent = '';
                document.getElementById('quote-continue').style.display = 'none';
                document.getElementById('quote-overlay').style.display = 'flex';
                
                // Add choice buttons
                const quoteBox = document.getElementById('quote-box');
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'display: flex; gap: 15px; justify-content: center; margin-top: 20px;';
                buttonContainer.innerHTML = `
                    <button id="explore-btn" style="padding: 12px 25px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                        🌺 Keep Exploring
                    </button>
                    <button id="newgame-btn" style="padding: 12px 25px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                        ⚔️ New Game
                    </button>
                `;
                quoteBox.appendChild(buttonContainer);
                
                document.getElementById('explore-btn').addEventListener('click', () => {
                    document.getElementById('quote-overlay').style.display = 'none';
                    buttonContainer.remove();
                    document.getElementById('quote-continue').style.display = 'block';
                });
                
                document.getElementById('newgame-btn').addEventListener('click', () => {
                    document.getElementById('quote-overlay').style.display = 'none';
                    buttonContainer.remove();
                    document.getElementById('quote-continue').style.display = 'block';
                    
                    // Enable New Game+ mode with divine party
                    newGamePlus = true;
                    enableDivineParty(); // Replace heroes with divine party
                    
                    // Reset game
                    dungeonLevel = 1;
                    defeatedSins.clear();
                    defeatedMythicalCreatures.clear(); // Reset mythical creature defeats for New Game+
                    inventory.holyWater = 3;
                    inventory.rosaries = 2;
                    inventory.gold = 0;
                    inventory.atkBoost = 0;
                    inventory.defBoost = 0;
                    inventory.hpBoost = 0;
                    inventory.virtueItems = [];
                    
                    // Clean up garden
                    if (gardenScene) {
                        while(gardenScene.children.length > 0) { 
                            const obj = gardenScene.children[0];
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                            gardenScene.remove(obj);
                        }
                        gardenScene = null;
                    }
                    gardenPlayerModel = null; // Reset garden player reference
                    
                    // Reset divine heroes
                    heroes.forEach(hero => {
                        hero.hp = hero.maxHp;
                        hero.mp = hero.maxMp;
                    });
                    
                    // Create Jesus player model for New Game+
                    createVisiblePlayerModel();
                    
                    // Generate dungeon with divine party
                    generateDungeon();
                    gameState = 'explore';
                    document.getElementById('title-screen').style.display = 'none';
                    document.getElementById('hud').style.display = 'block';
                    document.getElementById('crosshair').style.display = 'block';
                    
                    // Restore dungeon scene visibility
                    if (scene) {
                        scene.traverse((object) => {
                            if (object.isMesh) {
                                object.visible = true;
                            }
                        });
                    }
                    
                    startMusic(); // Start sacred music
                });
                
                return; // Exit early for cherubim special handling
            } else if (type === 'openbible') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        📖 THE HOLY SCRIPTURES 📖
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"All Scripture is God-breathed and is useful for teaching, rebuking, correcting and training in righteousness, so that the servant of God may be thoroughly equipped for every good work."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— 2 Timothy 3:16-17</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Your word is a lamp for my feet, a light on my path."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Psalm 119:105</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Heaven and earth will pass away, but my words will never pass away."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Matthew 24:35</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "In the beginning was the Word, and the Word was with God, and the Word was God. He was with God in the beginning. Through him all things were made; without him nothing was made that has been made."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— John 1:1-3</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        The Bible is the living Word of God, speaking truth and light into the hearts of all who seek Him.
                    </div>
                `;
            } else if (type === 'passage') {
                content = `
                    <div style="color: #f1c40f; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                        ${data.title}
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        ${data.text}
                    </div>
                    <div style="color: #f39c12; font-size: 12px; font-weight: bold;">
                        — ${data.reference}
                    </div>
                `;
            } else if (type === 'manna') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        🍞 MANNA FROM HEAVEN 🍞
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"Then the LORD said to Moses, 'I will rain down bread from heaven for you. The people are to go out each day and gather enough for that day.'"</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Exodus 16:4</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "The Israelites ate manna forty years, until they came to a land that was settled; they ate manna until they reached the border of Canaan. Your ancestors ate the manna in the wilderness, yet they died. But here is the bread that comes down from heaven, which anyone may eat and not die. I am the living bread that came down from heaven."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Exodus 16:35, John 6:49-51</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        The manna that sustained Israel in the wilderness points to Jesus, the true Bread of Life who came down from heaven to give us eternal life.
                    </div>
                `;
            } else if (type === 'tree_of_life') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        🌳 THE TREE OF LIFE 🌳
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"The LORD God made all kinds of trees grow out of the ground—trees that were pleasing to the eye and good for food. In the middle of the garden were the tree of life and the tree of the knowledge of good and evil."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Genesis 2:9</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Then the angel showed me the river of the water of life, as clear as crystal, flowing from the throne of God and of the Lamb down the middle of the great street of the city. On each side of the river stood the tree of life, bearing twelve crops of fruit, yielding its fruit every month. And the leaves of the tree are for the healing of the nations."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Revelation 22:1-2</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        "Blessed are those who wash their robes, that they may have the right to the tree of life and may go through the gates into the city."
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Revelation 22:14</div>
                    <div style="color: #7f8c8d; font-size: 12px; line-height: 1.5; margin-top: 15px;">
                        The Tree of Life, forbidden since the Fall, will be restored in the New Jerusalem where the redeemed will eat from it forever.
                    </div>
                `;
            } else if (type === 'angels') {
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        👼 THE NINE ORDERS OF ANGELS 👼
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        The angelic order consists of:
                    </div>
                    <div style="color: #FFD700; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 10px;">
                        <strong>Highest Orders</strong> which contemplate and adore God directly:<br>
                        • Seraphim • Cherubim • Thrones
                    </div>
                    <div style="color: #87CEEB; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 10px;">
                        <strong>Middle Orders</strong> which fulfill God's plan in the universe:<br>
                        • Dominions • Virtues • Powers
                    </div>
                    <div style="color: #98FB98; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>Lowest Orders</strong> which interact and serve humanity closely:<br>
                        • Principalities • Archangels • Angels
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        All Angels are far superior in power to the devil because the lowest of Angels is twice as powerful. Psalm 23 and 91 greatly demonstrate the power of having a good relationship with both God and our Guardian Angel/Angels.
                    </div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        St Padre Pio was known for having a close relationship with not only his own guardian angel but the guardian angels of others. Jesus can call upon a thousand of them at will.
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Based on Catholic Theology (St. Thomas Aquinas, Pseudo-Dionysius)</div>
                `;
            } else if (type === 'river') {
                const riverName = data.riverName || 'River';
                content = `
                    <div style="color: #f1c40f; font-size: 22px; font-weight: bold; margin-bottom: 15px;">
                        💧 THE ${riverName.toUpperCase()} 💧
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        <strong>"A river watering the garden flowed from Eden; from there it was separated into four headwaters. The name of the first is the Pishon... The name of the second river is the Gihon... The name of the third river is the Tigris... And the fourth river is the Euphrates."</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 11px; margin-bottom: 10px;">— Genesis 2:10-14</div>
                    <div style="color: #ecf0f1; font-size: 13px; line-height: 1.7; text-align: left; margin-bottom: 15px;">
                        These four rivers watered the Garden of Eden, bringing life to Paradise. They represent God's abundant provision flowing from His presence to sustain all creation.
                    </div>
                `;
            }
            
            document.getElementById('quote-text').innerHTML = content;
            document.getElementById('quote-author').textContent = '';
            document.getElementById('quote-continue').textContent = 'Continue Walking';
            document.getElementById('quote-overlay').style.display = 'flex';
            
            const btn = document.getElementById('quote-continue');
            const handler = () => {
                document.getElementById('quote-overlay').style.display = 'none';
                btn.removeEventListener('click', handler);
            };
            btn.addEventListener('click', handler);
        }

        // Add garden click handler when entering garden
        function enableGardenInteraction() {
            document.addEventListener('click', onGardenClick);
        }

        function disableGardenInteraction() {
            document.removeEventListener('click', onGardenClick);
        }

        function showFinalMessage() {
            // Automatically restart the garden walk - infinite peaceful loop
            gameState = 'garden';
            
            // Clean up current garden scene
            if (gardenScene) {
                while(gardenScene.children.length > 0) { 
                    const obj = gardenScene.children[0];
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                    gardenScene.remove(obj);
                }
                gardenScene = null;
            }
            gardenPlayerModel = null; // Reset garden player reference
            
            // Recreate garden and restart the walk
            createGardenOfEden();
        }

        function showOneRingVictory() {
            // Instantly transport to Garden of Eden - no delay
            showGameVictory();
        }

        // Event handlers
        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        function onMouseMove(e) {
            if (isPointerLocked && gameState === 'explore') {
                mouseX = e.movementX || 0;
                mouseY = e.movementY || 0;
            }
        }

        function onClick(e) {
            if (gameState === 'explore') {
                // Click-to-rotate camera around player
                const rect = renderer.domElement.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                
                // Calculate target rotation based on click position
                // Left side = rotate left, right side = rotate right
                const rotationAmount = x * Math.PI / 4; // Max 45 degrees per click
                targetRotationY -= rotationAmount; // Subtract to rotate correctly
            }
        }

        let resizeTimeout;
        function onWindowResize() {
            // Debounce resize events for better performance
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Update main camera
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                
                // Update renderer size and pixel ratio
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
                
                // Update garden camera if it exists
                if (gardenCamera) {
                    gardenCamera.aspect = width / height;
                    gardenCamera.updateProjectionMatrix();
                }
                
                // Update battle camera if it exists
                if (battleCamera) {
                    battleCamera.aspect = width / height;
                    battleCamera.updateProjectionMatrix();
                }
                
                // Update mobile detection on resize
                isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                           window.innerWidth < 768 ||
                           ('ontouchstart' in window) || 
                           (navigator.maxTouchPoints > 0);
                
                // Show/hide touch controls based on screen size
                const joystickLeft = document.getElementById('joystick-left');
                const joystickRight = document.getElementById('joystick-right');
                if (joystickLeft && joystickRight) {
                    if (isMobile) {
                        joystickLeft.style.display = 'block';
                        joystickRight.style.display = 'block';
                    } else {
                        joystickLeft.style.display = 'none';
                        joystickRight.style.display = 'none';
                    }
                }
                
                // Force a render to update the display immediately
                if (gameState === 'battle' && battleScene && battleCamera) {
                    renderer.render(battleScene, battleCamera);
                } else if (gameState === 'garden' && gardenScene && gardenCamera) {
                    renderer.render(gardenScene, gardenCamera);
                } else if (scene && camera) {
                    renderer.render(scene, camera);
                }
            }, 100); // 100ms debounce delay
        }

        // Handle orientation changes on mobile devices
        function onOrientationChange() {
            // Wait for the browser to finish orientation change
            setTimeout(() => {
                onWindowResize();
            }, 200);
        }

        // Fullscreen support for better immersion
        function requestFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { // IE11
                elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { // Safari
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { // IE11
                document.msExitFullscreen();
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                requestFullscreen();
            } else {
                exitFullscreen();
            }
        }

        // Detect fullscreen changes and adjust UI
        function onFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            if (isFullscreen) {
                // In fullscreen - maximize canvas
                document.body.style.overflow = 'hidden';
            } else {
                // Exited fullscreen
                document.body.style.overflow = 'hidden';
            }
            // Force resize to adjust to new dimensions
            setTimeout(onWindowResize, 100);
        }

        function checkWallCollision(x, z, radius = 0.5) {
            // Convert world position to grid position
            const gridX = Math.floor((x + MAP_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            const gridZ = Math.floor((z + MAP_SIZE * CELL_SIZE / 2) / CELL_SIZE);
            
            // Check surrounding cells for walls
            for (let dz = -1; dz <= 1; dz++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = gridX + dx;
                    const checkZ = gridZ + dz;
                    
                    if (checkX < 0 || checkX >= MAP_SIZE || checkZ < 0 || checkZ >= MAP_SIZE) {
                        return true; // Out of bounds
                    }
                    
                    if (dungeon[checkZ][checkX] === 1) {
                        // Wall exists - check if player is too close
                        const wallWorldX = (checkX - MAP_SIZE / 2) * CELL_SIZE;
                        const wallWorldZ = (checkZ - MAP_SIZE / 2) * CELL_SIZE;
                        
                        // Calculate distance from player to wall center
                        const dx = x - wallWorldX;
                        const dz = z - wallWorldZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        // Check if within collision radius (wall is CELL_SIZE/2 + player radius)
                        if (distance < CELL_SIZE / 2 + radius) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Game loop
        function update(dt) {
            if (gameState === 'explore') {
                // Hide mobile interact button during dungeon exploration
                if (isMobile) {
                    const interactBtn = document.getElementById('mobile-interact-btn');
                    if (interactBtn) interactBtn.style.display = 'none';
                }
                
                // Safety check: return early if player model not created yet
                if (!playerModel) {
                    // If we're in explore mode but playerModel doesn't exist, create it
                    try {
                        createVisiblePlayerModel();
                    } catch (e) {
                        // If creation fails, just return and try again next frame
                        return;
                    }
                    if (!playerModel) return;
                }
                
                // Movement - keyboard and touch (moves player model)
                const moveSpeed = MOVE_SPEED * dt;
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(camera.up, forward).normalize();
                
                // Calculate desired player position
                let desiredX = playerModel.position.x;
                let desiredZ = playerModel.position.z;
                let hasMoved = false;
                
                // Keyboard movement
                if (keys['w']) {
                    desiredX += forward.x * moveSpeed;
                    desiredZ += forward.z * moveSpeed;
                    hasMoved = true;
                }
                if (keys['s']) {
                    desiredX -= forward.x * moveSpeed;
                    desiredZ -= forward.z * moveSpeed;
                    hasMoved = true;
                }
                if (keys['a']) {
                    desiredX += right.x * moveSpeed;
                    desiredZ += right.z * moveSpeed;
                    hasMoved = true;
                }
                if (keys['d']) {
                    desiredX -= right.x * moveSpeed;
                    desiredZ -= right.z * moveSpeed;
                    hasMoved = true;
                }
                
                // Mobile joystick movement (fixed directions - no inversion)
                if (movementJoystick.active) {
                    desiredX -= right.x * movementJoystick.deltaX * moveSpeed;
                    desiredZ -= right.z * movementJoystick.deltaX * moveSpeed;
                    desiredX -= forward.x * movementJoystick.deltaY * moveSpeed;
                    desiredZ -= forward.z * movementJoystick.deltaY * moveSpeed;
                    hasMoved = true;
                }
                
                // Apply movement to player model only if no wall collision
                if (!checkWallCollision(desiredX, playerModel.position.z)) {
                    playerModel.position.x = desiredX;
                }
                if (!checkWallCollision(playerModel.position.x, desiredZ)) {
                    playerModel.position.z = desiredZ;
                }
                
                // Rotate player model to face movement direction
                if (hasMoved) {
                    const moveDirection = new THREE.Vector2(
                        desiredX - playerModel.position.x,
                        desiredZ - playerModel.position.z
                    );
                    if (moveDirection.length() > 0.01) {
                        playerModel.rotation.y = Math.atan2(moveDirection.x, moveDirection.y);
                    }
                }
                
                // Mobile camera joystick (horizontal rotation only)
                if (cameraJoystick.active) {
                    targetRotationY -= cameraJoystick.deltaX * 0.05;
                }
                
                // Camera follows player in third-person
                const cameraDistance = 5;
                const cameraHeight = 3;
                
                // Calculate camera position based on targetRotationY
                const targetCameraX = playerModel.position.x - Math.sin(targetRotationY) * cameraDistance;
                const targetCameraZ = playerModel.position.z - Math.cos(targetRotationY) * cameraDistance;
                
                // Smoothly move camera to target position
                camera.position.x += (targetCameraX - camera.position.x) * 0.15;
                camera.position.y = playerModel.position.y + cameraHeight;
                camera.position.z += (targetCameraZ - camera.position.z) * 0.15;
                
                // Make camera look at player
                camera.lookAt(playerModel.position.x, playerModel.position.y + 1, playerModel.position.z);
                
                // Update light position to follow player
                if (camera.userData.light) {
                    camera.userData.light.position.set(
                        playerModel.position.x,
                        playerModel.position.y + 5,
                        playerModel.position.z
                    );
                }
                
                // Check for enemy proximity (RPG-style encounter)
                for (let enemy of enemies) {
                    const distance = playerModel.position.distanceTo(enemy.mesh.position);
                    if (distance < 3) {
                        startBattle(enemy);
                        break;
                    }
                }
                for (let i = pickups.length - 1; i >= 0; i--) {
                    const pickup = pickups[i];
                    const distance = playerModel.position.distanceTo(pickup.mesh.position);
                    
                    if (distance < 2) {
                        scene.remove(pickup.mesh);
                        pickups.splice(i, 1);
                        
                        if (pickup.type === 'holyWater') {
                            inventory.holyWater++;
                            const hpIncrease = 10;
                            inventory.hpBoost += hpIncrease;
                            heroes.forEach(h => h.maxHp += hpIncrease);
                            showMessage(`Holy Water! +${hpIncrease} Max HP!`);
                        } else if (pickup.type === 'rosary') {
                            inventory.rosaries++;
                            const atkIncrease = 2;
                            inventory.atkBoost += atkIncrease;
                            showMessage(`Rosary! +${atkIncrease} ATK!`);
                        } else if (pickup.type === 'gold') {
                            const goldAmount = 10 + Math.floor(Math.random() * 20);
                            inventory.gold += goldAmount;
                            showMessage(`Found ${goldAmount} Gold!`);
                        }
                        
                        updateHUD();
                    }
                }
                
                // Rotate pickups
                pickups.forEach(p => {
                    p.mesh.rotation.y += dt * 2;
                    p.mesh.position.y = 1 + Math.sin(Date.now() * 0.002) * 0.2;
                });
                
                // Rotate enemies
                enemies.forEach(e => {
                    e.mesh.rotation.y += dt * 0.5;
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = 0.016; // ~60fps
            update(dt);
            
            if (gameState === 'battle' && battleScene && battleCamera) {
                updateBattleCamera();
                renderer.render(battleScene, battleCamera);
            } else if (gameState === 'garden' && gardenScene && gardenCamera) {
                updateGardenWalk(dt);
                renderer.render(gardenScene, gardenCamera);
            } else if (gameState === 'final' && gardenScene && gardenCamera) {
                renderer.render(gardenScene, gardenCamera);
            } else {
                renderer.render(scene, camera);
            }
        }

        // Initialize
        init3D();
        onWindowResize(); // Ensure proper initial sizing
        animate();
    </script>
</body>
</html>
